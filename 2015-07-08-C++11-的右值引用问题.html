<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>2015-07-08 C++11 的右值引用问题 - Wang Chunye</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="SUMMARY.html"><strong aria-hidden="true">1.</strong> Table Of Contents</a></li><li class="chapter-item expanded "><a href="2020-04-09-setup-c-IDE-for-emacs.html"><strong aria-hidden="true">2.</strong> 2020-04-09 setup emacs IDE for C/C++</a></li><li class="chapter-item expanded "><a href="2020-04-05-setup-rust-IDE-for-emacs.html"><strong aria-hidden="true">3.</strong> 2020-04-05 setup emacs IDE for Rust</a></li><li class="chapter-item expanded "><a href="2020-04-05-use-emacs-to-control-tmux.html"><strong aria-hidden="true">4.</strong> 2020-04-05 use emacs to control tmux</a></li><li class="chapter-item expanded "><a href="2020-04-04-start-to-use-mdbook.html"><strong aria-hidden="true">5.</strong> 2020-04-04 start to use mdbook</a></li><li class="chapter-item expanded "><a href="2019-04-22-从一个求和函数谈起.html"><strong aria-hidden="true">6.</strong> 2020-04-22 从一个求和函数谈起</a></li><li class="chapter-item expanded "><a href="2019-02-03-c++-可否同时抛出两个异常.html"><strong aria-hidden="true">7.</strong> 2019-02-03 c++ 可否同时抛出两个异常</a></li><li class="chapter-item expanded "><a href="2019-01-30-c++-中的-converting-constructor.html"><strong aria-hidden="true">8.</strong> 2019-01-30 c++ 中的 converting constructor</a></li><li class="chapter-item expanded "><a href="2019-01-30-深入理解-Return-Value-Optimization.html"><strong aria-hidden="true">9.</strong> 2019-01-30 深入理解 Return Value Optimization</a></li><li class="chapter-item expanded "><a href="2019-01-13-了解-ELF-文件格式.html"><strong aria-hidden="true">10.</strong> 2019-01-13 了解 ELF 文件格式</a></li><li class="chapter-item expanded "><a href="2019-01-01-vector.emplace_back-调用构造函数.html"><strong aria-hidden="true">11.</strong> 2019-01-01 vector.emplace_back 调用构造函数</a></li><li class="chapter-item expanded "><a href="2019-01-01-unique_ptr-的开销有多大.html"><strong aria-hidden="true">12.</strong> 2019-01-01 unique_ptr 的开销有多大</a></li><li class="chapter-item expanded "><a href="2017-07-09-计算一个整数有的二进制表示中多少个-1-.html"><strong aria-hidden="true">13.</strong> 2017-07-09 计算一个整数有的二进制表示中多少个 1 </a></li><li class="chapter-item expanded "><a href="2017-06-18-用c_c++-编写一个-list-操作程序-.html"><strong aria-hidden="true">14.</strong> 2017-06-18 用c/c++ 编写一个 list 操作程序 </a></li><li class="chapter-item expanded "><a href="2017-05-21-c++-中的高维数组-2-.html"><strong aria-hidden="true">15.</strong> 2017-05-21 c++ 中的高维数组(2)</a></li><li class="chapter-item expanded "><a href="2017-05-14-c++-中的高维数组-1-.html"><strong aria-hidden="true">16.</strong> 2017-05-14 c++ 中的高维数组(1)</a></li><li class="chapter-item expanded "><a href="2017-04-30-Walter-E.-Brown-讲解-c++-中的-metaprograming.html"><strong aria-hidden="true">17.</strong> 2017-04-30 Walter E. Brown 讲解 c++ 中的 metaprograming</a></li><li class="chapter-item expanded "><a href="2017-04-30-c++-中的-remove-erase-俗语.html"><strong aria-hidden="true">18.</strong> 2017-04-30 c++ 中的 remove-erase 俗语</a></li><li class="chapter-item expanded "><a href="2017-04-29-c++11-的-extern-template.html"><strong aria-hidden="true">19.</strong> 2017-04-29 c++11 的 extern template</a></li><li class="chapter-item expanded "><a href="2017-04-29-配置-haskell-的开发环境.html"><strong aria-hidden="true">20.</strong> 2017-04-29 配置 haskell 的开发环境</a></li><li class="chapter-item expanded "><a href="2017-04-29-c_c++-的编译和链接的问题.html"><strong aria-hidden="true">21.</strong> 2017-04-29 c/c++ 的编译和链接的问题</a></li><li class="chapter-item expanded "><a href="2017-04-23-c++-non-copyable-的传递性.html"><strong aria-hidden="true">22.</strong> 2017-04-23 c++ non copyable 的传递性</a></li><li class="chapter-item expanded "><a href="2017-04-06-ssh-的无密码登陆.html"><strong aria-hidden="true">23.</strong> 2017-04-06 ssh 的无密码登陆</a></li><li class="chapter-item expanded "><a href="2017-04-04-c++-GSL-中的-owner.html"><strong aria-hidden="true">24.</strong> 2017-04-04 c++ GSL 中的 owner</a></li><li class="chapter-item expanded "><a href="2017-04-04-c++-的-const-reference-extend-lifetime-rvalue.html"><strong aria-hidden="true">25.</strong> 2017-04-04 c++ 的 const reference extend lifetime rvalue</a></li><li class="chapter-item expanded "><a href="2017-04-03-有了c++11-的-unique_ptr，也许就不应该再使用-new_delete-关键字了.html"><strong aria-hidden="true">26.</strong> 2017-04-03 有了c++11 的 unique_ptr，也许就不应该再使用 new/delete 关键字了</a></li><li class="chapter-item expanded "><a href="2017-04-02-c++-的-universal-reference.html"><strong aria-hidden="true">27.</strong> 2017-04-02 c++ 的 universal reference</a></li><li class="chapter-item expanded "><a href="2017-04-02-c++-lambda-capture-by-value-的实验.html"><strong aria-hidden="true">28.</strong> 2017-04-02 c++ lambda capture by value 的实验</a></li><li class="chapter-item expanded "><a href="2017-03-26-c++-中-lambda-的类型和大小.html"><strong aria-hidden="true">29.</strong> 2017-03-26 c++ 中 lambda 的类型和大小</a></li><li class="chapter-item expanded "><a href="2017-03-26-c++-模板的类型推导.html"><strong aria-hidden="true">30.</strong> 2017-03-26 c++ 模板的类型推导</a></li><li class="chapter-item expanded "><a href="2017-03-16-使用--cmake-管理项目.html"><strong aria-hidden="true">31.</strong> 2017-03-16 使用  cmake 管理项目</a></li><li class="chapter-item expanded "><a href="2017-03-16-使用-google-test-framework.html"><strong aria-hidden="true">32.</strong> 2017-03-16 使用 google test framework</a></li><li class="chapter-item expanded "><a href="2017-03-16-google-c++-style-by-examples.html"><strong aria-hidden="true">33.</strong> 2017-03-16 google c++ style by examples</a></li><li class="chapter-item expanded "><a href="2017-03-13-TERMINAL-下的快捷操作.html"><strong aria-hidden="true">34.</strong> 2017-03-13 TERMINAL 下的快捷操作</a></li><li class="chapter-item expanded "><a href="2017-03-12-小叮当效应.html"><strong aria-hidden="true">35.</strong> 2017-03-12 小叮当效应</a></li><li class="chapter-item expanded "><a href="2017-03-12-存款准备金的意义.html"><strong aria-hidden="true">36.</strong> 2017-03-12 存款准备金的意义</a></li><li class="chapter-item expanded "><a href="2017-03-10-过拟合和正则化.html"><strong aria-hidden="true">37.</strong> 2017-03-10 过拟合和正则化</a></li><li class="chapter-item expanded "><a href="2017-03-09-Back-Propagation-算法的向量表示.html"><strong aria-hidden="true">38.</strong> 2017-03-09 Back Propagation 算法的向量表示</a></li><li class="chapter-item expanded "><a href="2017-03-09-成本函数与学习速度-sotfmax-函数与最大似然函数.html"><strong aria-hidden="true">39.</strong> 2017-03-09 成本函数与学习速度 sotfmax 函数与最大似然函数</a></li><li class="chapter-item expanded "><a href="2017-03-08-成本函数与学习速度.html"><strong aria-hidden="true">40.</strong> 2017-03-08 成本函数与学习速度</a></li><li class="chapter-item expanded "><a href="2017-03-08-用-Makefile-+-pandoc-+-markdown-写博客.html"><strong aria-hidden="true">41.</strong> 2017-03-08 用 Makefile + pandoc + markdown 写博客</a></li><li class="chapter-item expanded "><a href="2017-03-05-backpropagation.html"><strong aria-hidden="true">42.</strong> 2017-03-05 backpropagation</a></li><li class="chapter-item expanded "><a href="2017-02-07-理解-java-的-classloader.html"><strong aria-hidden="true">43.</strong> 2017-02-07 理解 java 的 classloader</a></li><li class="chapter-item expanded "><a href="2017-01-25-在-Java-中，我们尽量避免使用-null.html"><strong aria-hidden="true">44.</strong> 2017-01-25 在 Java 中，我们尽量避免使用 null</a></li><li class="chapter-item expanded "><a href="2017-01-14-Java-8-函数式编程例子.html"><strong aria-hidden="true">45.</strong> 2017-01-14 Java 8 函数式编程例子</a></li><li class="chapter-item expanded "><a href="2017-01-08-二分法查找.html"><strong aria-hidden="true">46.</strong> 2017-01-08 二分法查找</a></li><li class="chapter-item expanded "><a href="2017-01-08-最重要的设计原则.html"><strong aria-hidden="true">47.</strong> 2017-01-08 最重要的设计原则</a></li><li class="chapter-item expanded "><a href="2017-01-07-C-语言写的快排程序.html"><strong aria-hidden="true">48.</strong> 2017-01-07 C 语言写的快排程序</a></li><li class="chapter-item expanded "><a href="2017-01-07-编写单链表反转的程序.html"><strong aria-hidden="true">49.</strong> 2017-01-07 编写单链表反转的程序</a></li><li class="chapter-item expanded "><a href="2017-01-07-Feign-client.html"><strong aria-hidden="true">50.</strong> 2017-01-07 Feign client</a></li><li class="chapter-item expanded "><a href="2017-01-07-关于协议设计语言.html"><strong aria-hidden="true">51.</strong> 2017-01-07 关于协议设计语言</a></li><li class="chapter-item expanded "><a href="2017-01-07-简单的多线程并不能提高效率.html"><strong aria-hidden="true">52.</strong> 2017-01-07 简单的多线程并不能提高效率</a></li><li class="chapter-item expanded "><a href="2017-01-07-JAVA8-中的高阶函数.html"><strong aria-hidden="true">53.</strong> 2017-01-07 JAVA8 中的高阶函数</a></li><li class="chapter-item expanded "><a href="2017-01-07-JAVA-JSON-databinding-的多态.html"><strong aria-hidden="true">54.</strong> 2017-01-07 JAVA JSON databinding 的多态</a></li><li class="chapter-item expanded "><a href="2017-01-07-rxjava2-有什么新东西.html"><strong aria-hidden="true">55.</strong> 2017-01-07 rxjava2 有什么新东西</a></li><li class="chapter-item expanded "><a href="2017-01-07-阅读-Subscriber-的实现中关于--backpressure-的部分.html"><strong aria-hidden="true">56.</strong> 2017-01-07 阅读 Subscriber 的实现中关于  backpressure 的部分</a></li><li class="chapter-item expanded "><a href="2017-01-07-阅读-rxjava-源代码之----map.html"><strong aria-hidden="true">57.</strong> 2017-01-07 阅读 rxjava 源代码之  - map</a></li><li class="chapter-item expanded "><a href="2017-01-07-rxjava-如何和传统回调函数结合.html"><strong aria-hidden="true">58.</strong> 2017-01-07 rxjava 如何和传统回调函数结合</a></li><li class="chapter-item expanded "><a href="2017-01-07-阅读-rxjava-源代码.html"><strong aria-hidden="true">59.</strong> 2017-01-07 阅读 rxjava 源代码</a></li><li class="chapter-item expanded "><a href="2017-01-07-使用-Protobuf-设计-REST-API.html"><strong aria-hidden="true">60.</strong> 2017-01-07 使用 Protobuf 设计 REST API</a></li><li class="chapter-item expanded "><a href="2017-01-07-rabbitmq-中的概念.html"><strong aria-hidden="true">61.</strong> 2017-01-07 rabbitmq 中的概念</a></li><li class="chapter-item expanded "><a href="2016-12-25-从零开始构造一个微服务.html"><strong aria-hidden="true">62.</strong> 2016-12-25 从零开始构造一个微服务</a></li><li class="chapter-item expanded "><a href="2016-09-21-基于返回值的-java-generic-类型推导.html"><strong aria-hidden="true">63.</strong> 2016-09-21 基于返回值的 java generic 类型推导</a></li><li class="chapter-item expanded "><a href="2016-09-03-使用-Spring-Integration-Framework-写入-redis-队列.html"><strong aria-hidden="true">64.</strong> 2016-09-03 使用 Spring Integration Framework 写入 redis 队列</a></li><li class="chapter-item expanded "><a href="2016-08-27-开发自己的语言.html"><strong aria-hidden="true">65.</strong> 2016-08-27 开发自己的语言</a></li><li class="chapter-item expanded "><a href="2015-07-29-Erlang-application-environment.html"><strong aria-hidden="true">66.</strong> 2015-07-29 Erlang application environment</a></li><li class="chapter-item expanded "><a href="2015-07-10-ZFS-转移数据.html"><strong aria-hidden="true">67.</strong> 2015-07-10 ZFS 转移数据</a></li><li class="chapter-item expanded "><a href="2015-07-08-C++11-的右值引用问题.html" class="active"><strong aria-hidden="true">68.</strong> 2015-07-08 C++11 的右值引用问题</a></li><li class="chapter-item expanded "><a href="2015-07-08-C++-vector-调用多少次元素的构造函数.html"><strong aria-hidden="true">69.</strong> 2015-07-08 C++ vector 调用多少次元素的构造函数</a></li><li class="chapter-item expanded "><a href="2015-07-08-C++11-的-feature,-unique_ptr.html"><strong aria-hidden="true">70.</strong> 2015-07-08 C++11 的 feature, unique_ptr</a></li><li class="chapter-item expanded "><a href="2015-07-08-C_C++-中的求值顺序.html"><strong aria-hidden="true">71.</strong> 2015-07-08 C/C++ 中的求值顺序</a></li><li class="chapter-item expanded "><a href="2015-07-08-C_C++-编程风格:-if-else.html"><strong aria-hidden="true">72.</strong> 2015-07-08 C/C++ 编程风格: if-else</a></li><li class="chapter-item expanded "><a href="2015-07-08-编程风格：-C++-类的结构.html"><strong aria-hidden="true">73.</strong> 2015-07-08 编程风格： C++ 类的结构</a></li><li class="chapter-item expanded "><a href="2015-07-08-折腾-FreeBSD.html"><strong aria-hidden="true">74.</strong> 2015-07-08 折腾 FreeBSD</a></li><li class="chapter-item expanded "><a href="2015-06-01-C-Preprocessor-tricks.html"><strong aria-hidden="true">75.</strong> 2015-06-01 C Preprocessor tricks</a></li><li class="chapter-item expanded "><a href="2015-05-26-C++-should-support-C99-designated-initializer.html"><strong aria-hidden="true">76.</strong> 2015-05-26 C++ should support C99 designated initializer</a></li><li class="chapter-item expanded "><a href="2015-05-20-C++-virtual-function.html"><strong aria-hidden="true">77.</strong> 2015-05-20 C++ virtual function</a></li><li class="chapter-item expanded "><a href="2015-05-18-Understand-X86-64-calling-convention.html"><strong aria-hidden="true">78.</strong> 2015-05-18 Understand X86 64 calling convention</a></li><li class="chapter-item expanded "><a href="2015-05-05-Learning-inline-keyword-by-example-in-C.html"><strong aria-hidden="true">79.</strong> 2015-05-05 Learning inline keyword by example in C</a></li><li class="chapter-item expanded "><a href="2015-04-30-Different-key-binding-in-Emacs-transient-mark-mode.html"><strong aria-hidden="true">80.</strong> 2015-04-30 Different key binding in Emacs transient mark mode</a></li><li class="chapter-item expanded "><a href="2014-11-22-hello-world-in-C.html"><strong aria-hidden="true">81.</strong> 2014-11-22 hello world in C</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Wang Chunye</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#c11-的右值引用问题" id="c11-的右值引用问题">C++11 的右值引用问题</a></h1>
<p>C++11 中增加了一个新的特性，叫做“右值引用” (rvalue reference)。</p>
<p>主要参考文献</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">Rvalue Reference Quick Look</a></li>
<li><a href="https://pizer.wordpress.com/2009/04/13/c0x-do-people-understand-rvalue-references/">C++0x: Do people understand rvalue references?</a></li>
</ul>
<blockquote>
<p>Abstract</p>
</blockquote>
<blockquote>
<p>Rvalue references is a small technical extension to the C++
language. Rvalue references allow programmers to avoid logically
unnecessary copying and to provide perfect forwarding
functions. They are primarily meant to aid in the design of higer
performance and more robust libraries.</p>
</blockquote>
<p>注解</p>
<ol>
<li>为了避免无谓拷贝</li>
<li>为了提供完美转寄函数</li>
<li>主要目的是为了写通用库。</li>
</ol>
<p>个人以为，一般应用程序的作者，尽量别用这个功能。</p>
<h2><a class="header" href="#怎么理解这个功能呢" id="怎么理解这个功能呢">怎么理解这个功能呢？</a></h2>
<p>首先理解什么是左值，右值。十分困难给出一个严格的定义，个人觉得一下非正
式定义比较容易理解。</p>
<ol>
<li>能取地址的表达式，就是左值。</li>
<li>不是左值的表达式，就是右值。</li>
</ol>
<p>最常见的右值</p>
<ol>
<li>常量表达式 1 + 2,</li>
<li>函数调用参数的临时对象 <code>f(A_Class())</code>中 f 的实参。</li>
<li>函数调用的返回值产生的临时变量。</li>
</ol>
<p>最简单的一个例子</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
void foo(int &amp;&amp; a)
{
    cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; ' ' &lt;&lt; a &lt;&lt; endl;
}
void foo(int&amp; a)
{
    cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; ' ' &lt;&lt; a &lt;&lt; endl;
}
int bar()
{
    return 1000;
}
int main(int argc, char *argv[])
{
    int i = 100;
    foo(10);
    foo(i);
    foo(bar());
    return 0;
}
</code></pre>
<p>程序输出结果</p>
<pre><code class="language-console">% clang++ -ggdb -O0 -Wall -Werror -std=c++11 rvalue0.cpp &amp;&amp; ./a.out
void foo(int &amp;&amp;) 10
void foo(int &amp;) 100
void foo(int &amp;&amp;) 1000
</code></pre>
<p>普通函数调用重载理解了，就不难理解转移构造函数了。</p>
<h2><a class="header" href="#谨慎使用这个功能" id="谨慎使用这个功能">谨慎使用这个功能</a></h2>
<p>C++ 的编译器已经十分聪明，在一般情况下，已经尽最大可能避免无谓的对象拷
贝。例如</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
struct A {
    A();
    ~A();
    A(const A&amp; a);
    int value;
};
A::A()
{
    cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; &quot; &lt;&lt; (void*) this &lt;&lt; endl;
}
A::~A()
{
    cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; &quot; &lt;&lt; (void*) this &lt;&lt; endl;
}

A::A(const A&amp; a)
{
    cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; &quot; &lt;&lt; (void*) this &lt;&lt; endl;
}
A bar()
{
    A ret;
    cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; &quot; &lt;&lt; (void*) &amp;ret &lt;&lt; endl;
    return ret;
}
void foo(A x)
{
    cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; (void*)&amp;x &lt;&lt;endl;
}
int main(int argc, char *argv[])
{
    foo(bar());
    return 0;
}
</code></pre>
<p>结果如下</p>
<pre><code class="language-console">% clang++ -ggdb -O0 -Wall -Werror -std=c++11 rvalue0.cpp &amp;&amp; ./a.out
A::A() 0x7ffff687a968
A bar()
 0x7ffff687a968
void foo(A)0x7ffff687a968
A::~A() 0x7ffff687a968
</code></pre>
<h2><a class="header" href="#左值引用是右值" id="左值引用是右值">左值引用是右值</a></h2>
<pre><code class="language-cpp">void foo(A &amp;&amp; x){
    ...
    x
}
</code></pre>
<p>在函数体中，x 不是右值，而是左值，因为可以取到 x 的地址。</p>
<h2><a class="header" href="#stdmove-的作用" id="stdmove-的作用"><code>std::move</code> 的作用</a></h2>
<p>这函数就是一个强制类型转换，把左值转换为左值，没有任何函数开销。如果没
有这个函数，一般很难调用转移构造函数(move constructor)。</p>
<h2><a class="header" href="#可否返回一个临时对象的右值引用" id="可否返回一个临时对象的右值引用">可否返回一个临时对象的右值引用？</a></h2>
<pre><code class="language-cpp">A&amp;&amp; foo()
{
     A x;
     return std::move(A)
     // or return x;
}
</code></pre>
<p>无论怎样，和返回普通引用一样，导致程序崩溃。</p>
<h2><a class="header" href="#为什么有这个特性呢" id="为什么有这个特性呢">为什么有这个特性呢？</a></h2>
<ol>
<li>实现“可转移“ ， 和 std::move 相关</li>
<li>提供完美转寄函数，和 std::forward 相关。（perfect forwarding
function 怎么译？）</li>
</ol>
<h3><a class="header" href="#可转移" id="可转移">可转移</a></h3>
<p>有很多时候，对象是可移动的而是不可以拷贝的。上面参考文献给出三个例子</p>
<ol>
<li><code>fstream</code></li>
<li><code>unique_ptr</code> (这里)[{{site.baseurl}}/{% post_url 2015-07-08-C-------feature--unique-ptr %}</li>
<li>线程对象</li>
</ol>
<p>如果拷贝构造函数是私有函数，那么就是被禁止的。C++11 中有新特性，可以定
义 delete 函数。</p>
<p>一般来讲，一个对象拥有某一资源，例如内存，文件，线程等等，这种所有权是
不能与其他对象共享的，因为析构函数会释放资源，如果和别人共享，”别人“被
析构了，析构函数会释放资源，那么你手里就拿着一个被释放的资源。类似这样
的对象就是不可以拷贝的</p>
<p>但是_不可拷贝对象_并不是_不可转移对象_，假如拷贝了一个对象之后，但是源
对象放弃了所有权，那么目标对象就可以拥有所有权了。这个时候，我们不叫做
拷贝(copy)，叫做转移(move)。</p>
<pre><code class="language-cpp">ifstream foo()
{
    ifstream fs(__FILE__);
    return fs;
}
</code></pre>
<p>这个例子会有编译错误，因为 ifstream 没有可用的拷贝构造函数，即“不可拷
贝”。但是在新的标准里面，解决了这个问题。 可惜的是 GCC-4.8 还没有实现
这个 ifstream 的转移构造函数。为了凑数，下面用 <code>unique_ptr</code> 为例。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;memory&gt;
#include &lt;iterator&gt;
using namespace std;
unique_ptr&lt;ifstream&gt; foo()
{
    return std::move(unique_ptr&lt;ifstream&gt;(new ifstream(__FILE__)));
}
int main(int argc, char *argv[])
{
    unique_ptr&lt;ifstream&gt; fs = foo();
    copy(istreambuf_iterator&lt;char&gt;(*fs),istreambuf_iterator&lt;char&gt;(),
         ostream_iterator&lt;char&gt;(cout));
    return 0;
}
</code></pre>
<h2><a class="header" href="#完美转寄函数perfect-forward-function" id="完美转寄函数perfect-forward-function">完美转寄函数(Perfect Forward function)</a></h2>
<p>假设我们写一个函数 <code>g(a1)</code> ，就和调用 <code>f(a1)</code> 一模一样。很容易吗？</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
class A {
public:
    explicit A(int v);
    A(const A&amp; other);
    ~A();
public:
    int value;
};
A::A(int v):value(v)
{
    cout &lt;&lt; __PRETTY_FUNCTION__
         &lt;&lt; ' ' &lt;&lt; value
         &lt;&lt; ' ' &lt;&lt; (void*)this
         &lt;&lt; endl;
}
A::A(const A&amp; other):value(other.value)
{
    cout &lt;&lt; __PRETTY_FUNCTION__
         &lt;&lt; ' ' &lt;&lt; value
         &lt;&lt; ' ' &lt;&lt; (void*)this
         &lt;&lt; ' ' &lt;&lt; (void*)&amp;other
         &lt;&lt; endl;
}
A::~A()
{
    cout &lt;&lt; __PRETTY_FUNCTION__
         &lt;&lt; ' ' &lt;&lt; value
         &lt;&lt; ' ' &lt;&lt; (void*)this
         &lt;&lt; endl;
}
void f(A a)
{
    cout &lt;&lt; a.value &lt;&lt; endl;
}
template&lt;class T&gt;
void g(T a)
{
    f(a);
}

int main(int argc, char *argv[])
{
    A x(100);
    g&lt;A&gt;(x);
    return 0;
}
</code></pre>
<p>程序输出</p>
<pre><code class="language-console">A::A(int) 100 0x7fff48d239e8
A::A(const A &amp;) 100 0x7fff48d239e0 0x7fff48d239e8
A::A(const A &amp;) 100 0x7fff48d239a8 0x7fff48d239e0
100
A::~A() 100 0x7fff48d239a8
A::~A() 100 0x7fff48d239e0
A::~A() 100 0x7fff48d239e8
</code></pre>
<p>可以明显看到有一次多余拷贝构造函数。容易，改成引用就行了。</p>
<pre><code class="language-cpp">template&lt;class T&gt;
void g(T&amp; a)
{
    f(a);
}
</code></pre>
<p>这样的确避免了这次多余的拷贝构造函数，但是就没有那么通用了。所以我的体
会是，这个 rvalue reference 的功能是给库作者用的，普通应用程序，不用搞
得这么复杂。</p>
<p>不通用的原因是，如果传递常量引用，就会编译错误。</p>
<pre><code class="language-cpp">const A x(100);
g&lt;A&gt;(x);
</code></pre>
<p>你会说，容易改，弄一个函数重载就行了。</p>
<pre><code class="language-cpp">template&lt;class T&gt;
void g(T&amp; a)
{
    f(a);
}
template&lt;class T&gt;
void g(const T&amp; a)
{
    f(a);
}
</code></pre>
<p>搞定。</p>
<p>这样是搞定了，但是如果这样的函数多了，写起来十分难看，可读性也很差。
c++11 rvalue reference 这样解决了这个问题。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
class A {
public:
    explicit A(int v);
    A(const A&amp; other);
    A(A&amp;&amp; other);
    ~A();
public:
    int value;
};
A::A(int v):value(v)
{
    cout &lt;&lt; __FUNCTION__
         &lt;&lt; ' ' &lt;&lt; value
         &lt;&lt; ' ' &lt;&lt; (void*)this
         &lt;&lt; endl;
}
A::A(const A&amp; other):value(other.value)
{
    cout &lt;&lt; __PRETTY_FUNCTION__
         &lt;&lt; ' ' &lt;&lt; value
         &lt;&lt; ' ' &lt;&lt; (void*)this
         &lt;&lt; ' ' &lt;&lt; (void*)&amp;other
         &lt;&lt; endl;
}
A::A(A&amp;&amp; other):value(other.value)
{
    cout &lt;&lt; __FUNCTION__
         &lt;&lt; ' ' &lt;&lt; value
         &lt;&lt; ' ' &lt;&lt; (void*)this
         &lt;&lt; ' ' &lt;&lt; (void*)&amp;other
         &lt;&lt; endl;
}
A::~A()
{
    cout &lt;&lt; __FUNCTION__
         &lt;&lt; ' ' &lt;&lt; value
         &lt;&lt; ' ' &lt;&lt; (void*)this
         &lt;&lt; endl;
}
void f(A a)
{
    cout &lt;&lt; a.value &lt;&lt; endl;
}
template&lt;class T&gt;
void g(const T&amp;&amp; a)
{
    f(a);
}

int main(int argc, char *argv[])
{
    A x(100);
    g&lt;A&gt;(std::move(x));
    return 0;
}
</code></pre>
<p>写一个通用的完美转寄函数十分困难，标准已经弄好了。<code>std::forward</code></p>
<p>如何使用 std::forward</p>
<p>参考 (std::forward)[http://en.cppreference.com/w/cpp/utility/forward]</p>
<pre><code class="language-cpp">template&lt;class T&gt;
void wrapper(T&amp;&amp; arg)
{
    foo(std::forward&lt;T&gt;(arg)); // Forward a single argument.
}
</code></pre>
<ol>
<li>如果调用 wrapper 的实参是 <code>std::string</code> 类型的右值引用，那么 T 是
<code>std::string</code> （不是 <code>std::string&amp;</code> 也不是 <code>const std::string&amp;</code> 也
不是 <code>std::string&amp;&amp;</code>) ，那么 <code>std::forward</code> 保证传递右值引用给
<code>foo</code> 函数，即调用重载右值引用的 <code>foo</code>。</li>
<li>如果调用 wrapper 的实参是 左值常量的 <code>std::string</code> ，那么 <code>T</code> 是
<code>const std::string&amp;</code> 并且 <code>std::forward</code> 保证传递常量左值引用给
<code>foo</code> 函数，即调用重载常量左值引用的 <code>foo</code>。</li>
<li>如果调用 <code>wrapper</code> 的实参是非常量左值 <code>std::string</code>，那么 <code>T</code> 是
<code>std::string&amp;</code> ，并且 <code>std::forward</code> 保证传递非常量左值给 <code>foo</code> ，
即调用重载非常量左值的 <code>foo</code>。</li>
</ol>
<p>听上去比较复杂，简单理解就是，怎么调用 <code>wrapper</code> ，就怎么调用 <code>foo</code> ，
不用写很多的重载函数，只用一个 <code>wrapper</code> 函数，利用 <code>std::forward</code> ，
就可以找到合适版本的 foo，就算 foo 有很多个重载版本。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;
void foo(std::string&amp;&amp; a)
{
    cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; &quot; &lt;&lt;  a &lt;&lt; endl;
}
void foo(const std::string&amp; a)
{
    cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; &quot; &lt;&lt;  a &lt;&lt; endl;
}
void foo(string&amp; a)
{
    cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; &quot; &lt;&lt;  a &lt;&lt; endl;
}
template&lt;class T&gt;
void wrapper(T&amp;&amp; arg)
{
    foo(std::forward&lt;T&gt;(arg)); // Forward a single argument.
}

int main(int argc, char *argv[])
{
    string a = &quot;lvalue&quot;;
    const string b = &quot;const lvalue&quot;;
    wrapper(string(&quot;rvalue&quot;));
    wrapper(b);
    wrapper(a);

    return 0;
}
</code></pre>
<p>输出结果</p>
<pre><code class="language-console">% lang++ -ggdb -O0 -Wall -Werror -std=c++11 forward3.cpp &amp;&amp; ./a.out
void foo(std::string &amp;&amp;) rvalue
void foo(const std::string &amp;) const lvalue
void foo(string &amp;) lvalue
</code></pre>
<p>别重新发明轮子了，标准库已经做好了，而且这个工作并不简单。</p>
<h2><a class="header" href="#不要用右值引用代替返回值优化" id="不要用右值引用代替返回值优化">不要用右值引用代替返回值优化</a></h2>
<p>前面说了 C++11 rvalue reference 的两个用处。经常看到有人说，还有一个用
处，就是，如果一个函数返回一个临时变量， rvalue reference 可以提高性能。
我觉得这是一个误解， 返回值优化 (RVO) 已经是十分成熟的技术，不需要
rvalue reference ，有了这个，反而更慢。前面的例子已经看到，C++ 编译器
足够聪明，很多情况下已经避免了无谓拷贝。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
class A {
public:
    explicit A(int v);
    A(const A&amp; other);
    A(A&amp;&amp; other);
    ~A();
public:
    int value;
};
A::A(int v):value(v)
{
    cout &lt;&lt; __FUNCTION__
         &lt;&lt; ' ' &lt;&lt; value
         &lt;&lt; ' ' &lt;&lt; (void*)this
         &lt;&lt; endl;
}
A::A(const A&amp; other):value(other.value)
{
    cout &lt;&lt; __PRETTY_FUNCTION__
         &lt;&lt; ' ' &lt;&lt; value
         &lt;&lt; ' ' &lt;&lt; (void*)this
         &lt;&lt; ' ' &lt;&lt; (void*)&amp;other
         &lt;&lt; endl;
}
A::A(A&amp;&amp; other):value(other.value)
{
    cout &lt;&lt; __FUNCTION__
         &lt;&lt; ' ' &lt;&lt; value
         &lt;&lt; ' ' &lt;&lt; (void*)this
         &lt;&lt; ' ' &lt;&lt; (void*)&amp;other
         &lt;&lt; endl;
}
A::~A()
{
    cout &lt;&lt; __FUNCTION__
         &lt;&lt; ' ' &lt;&lt; value
         &lt;&lt; ' ' &lt;&lt; (void*)this
         &lt;&lt; endl;
}
A f()
{
    return A(100);
}
int main(int argc, char *argv[])
{
    A x = f();
    return 0;
}
</code></pre>
<p>这个例子中</p>
<pre><code class="language-console">% clang++ -ggdb -O0 -Wall -Werror -std=c++11 rvo.cpp &amp;&amp; ./a.out
A 100 0x7fff76a18a78
~A 100 0x7fff76a18a78
</code></pre>
<p>可以看到，没有任何多多余动作，RVO 工作的很好。我们画蛇添足一下，用
rvalue reference 看看。</p>
<p>改成</p>
<pre><code class="language-cpp">A &amp;&amp; x = f()
</code></pre>
<p>程序输出没有任何变化。</p>
<p>如果</p>
<pre><code class="language-cpp">return A(100) =&gt; return std::move(A(100))
</code></pre>
<p>反倒多了一次转移构造函数的调用和临时对象的析构。</p>
<h2><a class="header" href="#总结" id="总结">总结</a></h2>
<ol>
<li>右值引用是为了库函数作者用的，尤其是模板库。普通应用程序尽量不要用，
除非你真正理解这个功能。</li>
<li><code>std::move</code> 经常和转右值构造函数配合使用，转移构造函数的形参是右值引用。</li>
<li><code>std::forward</code> 利用右值引用。尽量用这个。</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="2015-07-10-ZFS-转移数据.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="2015-07-08-C++-vector-调用多少次元素的构造函数.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="2015-07-10-ZFS-转移数据.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="2015-07-08-C++-vector-调用多少次元素的构造函数.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-98267158-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        
        <script type="text/javascript">
            window.playpen_line_numbers = true;
        </script>
        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
