---
layout: post
title:  "开发自己的语言"
date:   2016/08/27 16:13:26
categories:
comments: true
---



本文大多数参考 [SICP][]

[SICP]: https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-25.html#%_chap_4


阴阳大法

![ying-yan][]

[ying-yan]: https://mitpress.mit.edu/sicp/full-text/book/ch4-Z-G-1.gif


一个语言的解释器，就是一个 eval 函数，就是求值函数：

 * 输入： 一个表达式 `s-exp`
 * 输出： 一个表达式 `s-exp`

这个解释器的核心就是 `apply` 和 `eval` 之间的互递归调用。

## 什么是 `s-exp` 和 `s-exp` 的求值规则

### 原始类型

原始类型是一个 `s-exp` ，求值就是 `s-exp` 本身。包括：整数，浮点数，字符串。例如

```
1  => 1
1.2 => 1.2
"abc" => "abc"
```

这个规则看上去很简单，但是很重要，他是递归求值的终止条件。也就是说，
`eval` 函数碰到这些原始类型的 `s-exp` ，不会递归调用 `apply` 。

根据这个规则，我们写一个函数

```scheme
(define (my-eval exp env)
  (cond ((self-evaluating? exp) exp)
        (else (error "Unknown expression type -- EVAL" exp))))

(define (self-evaluating? exp)
  (cond ((number? exp) #t)
        ((string? exp) #t)
        (else #f)))
```

我们运行一下这个函数。首先我们需要安装一个 scheme 解释器，参考 <https://github.com/cisco/ChezScheme>
语言参考 <http://www.scheme.com/tspl4/>


```
Chez Scheme Version 9.4
Copyright 1984-2016 Cisco Systems, Inc.

> (load "eval0.scm")
> (my-eval 1 '())
1
> (my-eval 1.2 '())
1.2
> (my-eval "abc" '())
"abc"
> (my-eval (list 1 2 3) '())
Exception in error: invalid message argument (1 2 3)
Type (debug) to enter the debugger.
```

恭喜你，一个解释器的雏形开始了。这里有一个开发原则，“永远有一个可以工
作的版本”。我经历过两种开发模式。

 1. 写了一天的代码，从来没有编译运行过。然后花三天去调试。
 2. 写几分钟的代码，然后立即调试。循环往复，每次增加功能一点点。

第一种模式下，大多数情况是，我自己思路不很清晰，模块还没有分解到足够细
致，所以一边写代码，一遍划分模块。

第二种模式下，我已经思路很清晰了，代码模块也很清晰了，尤其是模块划分的
颗粒度足够细致，脑子里面已经有具体的迭代步骤了。这种模式下，开发效率高
一些。

可以看到，`(my-eval (list 1 2 3) '()` 的时候，出现错误。这里也有一个开
发原则，“测试你的每一行代码”。可以看到，这几个简单的测试，覆盖了刚刚写
的所有代码。

开发初期，保证代码的测试覆盖率相对容易。这个时候，最好配合自动回归测试，
保证以后代码的覆盖率。如果开发初期没有把自动化测试做好，到了开后中后期，
在回过头来想保证代码的测试覆盖率，难度就十分大了。

好了，我们继续迭代开发我们的解释器。

### 特殊型 (special form)

#### quote 引用
这个规则也是一个终止条件。
