---
layout: post
title:  "开发自己的语言"
date:   2016/08/27 16:13:26
categories:
comments: true
---



本文大多数参考 [SICP][]

[SICP]: https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-25.html#%_chap_4


阴阳大法

![ying-yan][]

[ying-yan]: https://mitpress.mit.edu/sicp/full-text/book/ch4-Z-G-1.gif


一个语言的解释器，就是一个 eval 函数，就是求值函数：

 * 输入： 一个表达式 `s-exp`
 * 输出： 一个表达式 `s-exp`

这个解释器的核心就是 `apply` 和 `eval` 之间的互递归调用。

## 什么是 `s-exp` 和 `s-exp` 的求值规则

### 原始类型

原始类型是一个 `s-exp` ，求值就是 `s-exp` 本身。包括：整数，浮点数，字符串。例如

```
1  => 1
1.2 => 1.2
"abc" => "abc"
```

这个规则看上去很简单，但是很重要，他是递归求值的终止条件。也就是说，
`eval` 函数碰到这些原始类型的 `s-exp` ，不会递归调用 `apply` 。

根据这个规则，我们写一个函数

```scheme
(define true #t)
(define false #f)
(define (my-eval exp env)
  (cond ((self-evaluating? exp) exp)
        (else (error "Unknown expression type -- EVAL" exp))))

(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))
```

我们运行一下这个函数。首先我们需要安装一个 scheme 解释器，参考 <https://github.com/cisco/ChezScheme>
语言参考 <http://www.scheme.com/tspl4/>


```
Chez Scheme Version 9.4
Copyright 1984-2016 Cisco Systems, Inc.

> (load "eval0.scm")
> (my-eval 1 '())
1
> (my-eval 1.2 '())
1.2
> (my-eval "abc" '())
"abc"
> (my-eval (list 1 2 3) '())
Exception in error: invalid message argument (1 2 3)
Type (debug) to enter the debugger.
```

恭喜你，一个解释器的雏形开始了。这里有一个开发原则，“永远有一个可以工
作的版本”。我经历过两种开发模式。

 1. 写了一天的代码，从来没有编译运行过。然后花三天去调试。
 2. 写几分钟的代码，然后立即调试。循环往复，每次增加功能一点点。

第一种模式下，大多数情况是，我自己思路不很清晰，模块还没有分解到足够细
致，所以一边写代码，一遍划分模块。

第二种模式下，我已经思路很清晰了，代码模块也很清晰了，尤其是模块划分的
颗粒度足够细致，脑子里面已经有具体的迭代步骤了。这种模式下，开发效率高
一些。

可以看到，`(my-eval (list 1 2 3) '()` 的时候，出现错误。这里也有一个开
发原则，“测试你的每一行代码”。可以看到，这几个简单的测试，覆盖了刚刚写
的所有代码。

开发初期，保证代码的测试覆盖率相对容易。这个时候，最好配合自动回归测试，
保证以后代码的覆盖率。如果开发初期没有把自动化测试做好，到了开后中后期，
在回过头来想保证代码的测试覆盖率，难度就十分大了。

好了，我们继续迭代开发我们的解释器。


### my-quote

这个规则也是一个终止条件。如果一个 `s-exp` 是一个 `list` ，第一个元素
是 `my-quote`，第二个元素任何一个 `s-exp` X，那么求值结果就是 X 。

```
(my-quote 1) => 1
(my-quote 1.2) => 1.2
(my-quote "abc") => "abc
(my-quote (1 2 3)) => (1 2 3)
(my-quote a-symbol) => a-symbol
(my-quote my-quote) => my-quote
```

`s-exp` 中有一个重要的数据类型，就是 symbol 。 quote 可以得到 symbol
本身。


```scheme
(define (my-eval exp env)
  (cond (......
        ((quoted? exp) (text-of-quotation exp))
         ......
        (else (error "Unknown expression type -- EVAL" exp))))
```

我们看看 `quoted?` 和 `(text-of-quotation)` 怎么实现的？

```scheme
(define (quoted? exp)
  (tagged-list? exp 'my-quote))
(define (text-of-quotation exp) (cadr exp))
(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))
```

看看运行结果

```
> (load "eval1.scm")
> (my-eval '(my-quote 1) '())
1
> (my-eval '(my-quote 1.2) '())
1.2
> (my-eval '(my-quote "hello") '())
"hello"
> (my-eval '(my-quote a-symbol) '())
a-symbol
> (my-eval '(my-quote my-quote) '())
my-quote
```

`eval1.scm` 的完整内容如下

```scheme
(define true #t)
(define false #f)
(define (my-eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((quoted? exp) (text-of-quotation exp))
        (else (error "Unknown expression type -- EVAL" exp))))

(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))

(define (quoted? exp)
  (tagged-list? exp 'my-quote))
(define (text-of-quotation exp) (cadr exp))
(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))

```

一个好的程序风格是，多写一些小的函数，然后组合这些函数。函数都有名字，
可以描述自己的作用。例如 `text-of-quotation` 。其实这个函数本质上和
`cadr` 没有任何区别。但是在逻辑层次上，`text-of-quotation` 是更加高层
的函数，`cadr` 是更加底层的函数。这种逻辑层次的划分，可以提高程序的可
读性。

因为 `eval` , `quote` , `if` , `cond` 等等，都是 scheme 自带的关键字，
原 SICP 中直接使用的这些关键字，为了加以区别，我修改成了 `my-eval` ,
`my-quote`, `my-if`, `my-cond` 等等。这种区分不是必须的。

### my-if

支持条件表达式，输入 `s-exp` 是一个 list ，有四个元素：

 1. 第一个元素是 `my-if` ，表明是一个条件表达式。
 2. 第二个元素是判断条件 `<C>`
 3. 第三个元素是 `<T>` 为真的时候，`s-exp` 的求值结果。
 4. 第三个元素是 `<F>` 为假的时候，`s-exp` 的求值结果。


这里有一个语言设计的问题，是否有必要增加一个 boolean 的数据类型？什么
是真，什么是假？这里有很多让人难以捉摸的小细节。这个问题也是各种语言之
间争论很久的话题。为了简单，我们不在这个问题上展开讨论，我们不增加新的
数据类型，认为符号(symbol) `true` 是真，其他值都是假。


```scheme
(define (my-eval exp env)
  (cond (......
        ((if? exp) (eval-if exp env))
         ......
        (else (error "Unknown expression type -- EVAL" exp))))
```

先看看 `if?` 的实现。

```scheme
(define (if? exp) (tagged-list? exp 'my-if))
```

感谢逻辑分层的代码风格，`if?` 的实现的可读性就很好了。

我们看看关键的 `eval-if` 怎么实现的。

```scheme
(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))
```

这里有两点需要注意

 1. 递归调用， `eval-if` 递归调用了 `my-eval` ，可以看到递归调用的强大之处。
 2. 求值顺序。

“求值顺序” 是一门语言的一个重大的设计问题。不同的求值顺序，导致完全不同
的效果。这里我们注意到，如果求值条件为真，那么假的分支是不做求值的。如
果求值条件为假，那么真的分支是不会求职的。这种设计叫做短路求值
(short-circuit)。 主流语言都是这么设计的。求值顺序是一个很重要的课题，
这里不展开讨论。


看看其他辅助函数如何实现的。这里再次应用了逻辑分层的代码风格。

```scheme
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))
(define (true? exp)
  (eq? exp 'true))
```

我们看看程序的执行效果


```
> (my-eval '(my-if (my-quote true) 1 2) '())
1
> (my-eval '(my-if (my-quote false) 1 2) '())
2
```

非常好。 这里是完整的代码

```scheme
(define true #t)
(define false #f)
(define (my-eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((quoted? exp) (text-of-quotation exp))
        ((if? exp) (eval-if exp env))
        (else (error "Unknown expression type -- EVAL" exp))))

(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))
(define (if? exp) (tagged-list? exp 'my-if))

(define (eval-if exp env)
  (if (true? (my-eval (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))

(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))
(define (true? exp)
  (eq? exp 'true))

(define (quoted? exp)
  (tagged-list? exp 'my-quote))
(define (text-of-quotation exp) (cadr exp))
(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))

```

### 代码块求值

这个功能是一个很方便的功能。如果 `<s-exp>` 是下面的形式

```
(my-begin <E1> <E2> .... <En>)
```

那么我们对 E1 , E2 ，.... , En 分别求值，整个表达式的值就是 En 的求值结果。

```
(define (my-eval exp env)
  (cond (.......
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ......
```

看看关键函数 `eval-sequence` 的实现

```
(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (my-eval (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))
```

这里注意
 1. 求值顺序
 2. 递归调用 `my-eval`
 3. 中间的表达式的求值结果被丢弃了

看看其他几个辅助函数的实现

```
(define (begin? exp) (tagged-list? exp 'my-begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))
```

看看程序的执行效果

```
> (load "eval3.scm")
> (my-eval '(my-begin 1 2) '())
```

下面是完整的程序代码

```scheme
(define true #t)
(define false #f)
(define (my-eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((quoted? exp) (text-of-quotation exp))
        ((if? exp) (eval-if exp env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        (else (error "Unknown expression type -- EVAL" exp))))

(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))
(define (if? exp) (tagged-list? exp 'my-if))

(define (eval-if exp env)
  (if (true? (my-eval (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))

(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))
(define (true? exp)
  (eq? exp 'true))

(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else (my-eval (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))

(define (begin? exp) (tagged-list? exp 'my-begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

(define (quoted? exp)
  (tagged-list? exp 'my-quote))
(define (text-of-quotation exp) (cadr exp))
(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))
```

### 函数的求值

什么是函数表达式，其实就是著名的 lambda 表达式。lambda 表达式格式如下

```
(my-lambda <PARAM-LIST> <FUN-BODY>)
```

`PARAM-LIST` 是一个变量列表，引入变量的作用域，也叫环境。我们在求值
`FUN-BODY` 的时候，就在最内层的环境开始，有里向外的搜索变量。重名的时
候，内层变量先起作用，就这个就是所谓的阴影效果 (shadow) 。

求值一个 lambda 表达式的时候，返回值就是一个 “函数” 。

程序内部，如何表达一个函数呢？这也是一个重大的语言设计问题。编译型还是
解释型？目标语言的选择，字节码，还是机器码，还是其他的中间语言？

我们这个简单的语言中，我们就用 list 来表示。

```scheme
(define (make-procedure parameters body env)
   (list 'procedure parameters body env))
```

可见一个函数有三个元素，参数列表，函数体，和环境。

那么，我们先实现一个 lambda 表达式的解析。

```scheme
(define (my-eval exp env)
  (cond (.......
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ......
```

其他几个辅助函数的实现

```scheme
(define (lambda? exp) (tagged-list? exp 'my-lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))
```




```
> (lambda? '(my-lambda 1))
#f
> (lambda-parameters '(my-lambda (a b) (+ a b)))
(a b)
> (lambda-body '(my-lambda (a b) (+ a b)))
((+ a b))
> (make-procedure '(a b) '((+ a b)) '())
(procedure (a b) ((+ a b)) ())
> (my-eval '(my-lambda (a b) (+ a b)) '())
(procedure (a b) ((+ a b)) ())
```

太好了，我们可以解析 lambda 表达式了。

这里是完整的代码

```scheme
(define true #t)
(define false #f)
(define (my-eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((quoted? exp) (text-of-quotation exp))
        ((if? exp) (eval-if exp env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        (else (error "Unknown expression type -- EVAL" exp))))

(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))
(define (if? exp) (tagged-list? exp 'my-if))

(define (eval-if exp env)
  (if (true? (my-eval (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))

(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))
(define (true? exp)
  (eq? exp 'true))

(define (lambda? exp) (tagged-list? exp 'my-lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else (my-eval (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))

(define (begin? exp) (tagged-list? exp 'my-begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

(define (quoted? exp)
  (tagged-list? exp 'my-quote))
(define (text-of-quotation exp) (cadr exp))
(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))
```




一个变量用一个 symbol 来表示，也就是说，如果 `my-eval` 输入 `s-exp` 是
一个 symbol 的时候，`my-eval` 怎么求值。

变量的作用域也是一个重大的语言设计问题。不同的语言有不同的设计，展现了
不同语言丰富的表达能力。现在主流语言是“词法作用域” (lexical scope) 。
我们做出一个简单的词法作用域的实现。

讲词法作用域的时候，不可避免的要说到函数的定义。
