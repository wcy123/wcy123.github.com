---
layout: post
title:  "ej 的设计改进"
date:   2015/08/08 21:00:10
categories:
comments: true
draft: true
---



根据 P426 "erlang programming" 的建议

 1. 只用很少的进程
 2. 进程只干真正需要并行干的事

其中有一段

> If you are dealing with users logged in to a systerm, this probably
> not equate to a process for every session. Instead, you will have a
> process for every event entering the system.


这样，我们可以有这样的设计

 - 一个主进程管理所有的连接
 - 当有一个新的 tcp 数据包收到的时候
     - 创建一个临时进程
     - 转移 socket 的所有权给临时进程
     - 转移状态给临时进程
     - 临时进程处理消息
     - 发送响应数据，注意，`gen_tcp:send` 也许会阻塞住
     - 干完了，把状态和 socket 的控制权还给主进程。
 - 这个进程继续处理新的数据。保证快速响应用户数据


优点

 - 可以防止悬空 socket 。
     - 如果临时进程产生异常，将不会交还 Socket 回给主进程
     - 如果临时进程出现意外，socket 讲自动关闭。
 - 关于连接的状态也被自动回收
 - socket 是 session 的唯一标识。
 - 因为有很多的临时进程，可以防止 GC，因为快速结束的进程自动释放内存，不需要 GC 参与。
 - 方便管理进程的生命期
     - 两个互相协同工作（同生同死）的 `gen_server` 还不是很容易设计
     - 要让他们都正常退出
     - 如果不是正常退出，会产生 crash report

缺点

 - 需要频繁的拷贝状态，在主进程和临时进程之间。




## tcp 链接的管理。


见 https://github.com/wcy123/etcp_server

 - `etcp_listener_sup` 建立并管理监听进程。
 - 监听进程创建一个临时工作进程。
 - 工作进程等待监听进程通知。
 - 监听进程等待新的 tcp 连接。

当有新的 tcp 连接的时候

 - 监听进程要迅速恢复到监听状态
     - 监听进程把 socket 控制权转移给临时工作进程
     - 通知临时工作进程展开工作
     - 启动新的临时工作进程，继续等待监听进程通知。
     - 监听进程立刻重新进入监听状态。
 - 临时工作进程得到通知后
     - 调用回调函数，创建/得到真正的工作进程
     - 转移 socket 的控制权，给真正的工作进程。
     - 发送  `become_controller` 给真正的工作进程
     - 自己正常结束了。


## 主进程的状态管理

参见 `benchmark` 的比较

 - `process dictionary`
 - `dict`
 - `ets`
 - `gb_tree`
 - `array`

最后胜出的是  `gb_tree`

性能最快的是 `process dictionary` ，但是为啥不用呢

 - `process_info` 会拷贝 `process dictionary`
 - 很多远程调用 `Module:Function` 会调用，`process_info`
 - 产生大量不可预料的拷贝，所以，尽量不要使用 `process dictionary`。


todo: 增加参考链接。


## 协议栈的设计

```
  +------------------------------------+
  |    ej_c2s                          |
  +------------------------------------+
  |  ej_c2s_raw_transport(xml  stream) |
  +------------------------------------+

```

底层 transport layer 需要提供的服务有

 - `send(xml)`
 - 主动发送消息，xml stream
