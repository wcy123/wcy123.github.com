<html>
  <head>
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
</script>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>在 Java 中，我们尽量避免使用 null</title>

  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../writ.min.css">
</head>
<body>
<main>
<header>
<h1>在 Java 中，我们尽量避免使用 null</h1>
<h3 class="date">2017/01/25 14:47:40</h3>
</header>
<article>
<p>null 在 java 里面是一个十分特殊的值，他可以是任何类型。我们应该尽量避免使用这个值，主要原因是当你使用任何 method 的时候，都会导致 NPE (NullPointerException)。</p>
<p>例如，</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">if</span>(xxx.<span class="fu">equals</span>(<span class="st">&quot;hello&quot;</span>)) {
    ...
}</code></pre></div>
<p>这里 <code>xxx</code> 有可能是 null ，会导致 NPE ，所以有的时候，我们按照下面的方式写。</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">if</span>(<span class="st">&quot;hello&quot;</span>.<span class="fu">equals</span>(xxx)) {
    ...
}</code></pre></div>
<p>但是如果比较 <code>xxx</code>, <code>yyy</code> 就麻烦了，</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">if</span>(xxx.<span class="fu">equals</span>(yyy)) {
    ...
}</code></pre></div>
<p>如果 <code>xxx</code> 是 null, 也会导致 NPE ，于是我们按照下面的方式写</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">if</span>(xxx!=<span class="kw">null</span> &amp;&amp; xxx.<span class="fu">equals</span>(yyy)){
    ...
}</code></pre></div>
<p>但是，如果 <code>yyy</code> 也是 null ，这个判断结果是 <code>false</code> 。这个根据业务逻辑，某些情况下合理，某些情况下不合理。</p>
<p>甚至下面的代码都会可能产生 NPE</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">Boolean flag = <span class="fu">getFlag</span>();
<span class="kw">if</span>(flag) {
...
}</code></pre></div>
<p>如果 flag 是 null ，就崩了。 Boolean 本来建模的是一个类型，类型中是一个集合，里面有两个元素，True 和 False ，可惜 Java 语言中，实际上是三值元素的集合，因为还有 null 这个万能值。这个严重影响了语义表达，影响建模。</p>
<p>如此基本的操作都会导致这么麻烦的代码和逻辑，那么，我们不如约定，所有的引用值，都不允许是 null 。某些注明的第三方库已经应用这种模式，例如 rxjava 2.0 。 rxjava 1.0 允许流中可以观察到 null 的值，而 rxjava 2.0 对此作出改进, 规定流中如果观察到了 null ，库直接抛 NPE 。 Guava 里面的某些类的设计，也是基于此原则。</p>
<p>如果有了这样一个约定，“所有引用值都不是 null ”，以上问题都解决了。也就是说，如果出现 NPE ，那么就以为这严重的逻辑 bug 。</p>
<p>有人想，如果我就想建模“可选”这个概念，如果某个操作成功，返回有效引用，如果失败，返回 null 。</p>
<p>有两个解决方案</p>
<ol style="list-style-type: decimal">
<li>改变设计，如果“操作”和 IO 相关，那么失败的时候，不是返回 null ，而是抛出自定异常。</li>
<li>如果“操作”和 IO 无关，不适合抛出自定义异常，那么使用 Optional 。</li>
</ol>
<p>Java 8 里面提供了 java.util.Optional 这个类，显式建模这个“失败”的概念。</p>
<pre><code>Integer parseInterger(String x){
   return Integer.valueOf(x)
}</code></pre>
<p>上面的代码采用了第一种方案，如果转换整数失败，那么抛出 <code>java.lang.NumberFormatException</code> 的异常。</p>
<p>如果调用者不想处理异常，我们可以改成第二种方案。</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">Optional&lt;Integer&gt; <span class="fu">parseInteger</span>(String x) {
    <span class="kw">try</span> {
       <span class="kw">return</span> Optional.<span class="fu">of</span>(Integer.<span class="fu">valueOf</span>(x));
    }<span class="kw">catch</span> (NumberFormatException e){
       <span class="kw">return</span> Optional.<span class="fu">empty</span>();
    }
}</code></pre></div>
<p>这个时候，调用者就需要</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">final</span> Optional&lt;Integer&gt; aInt = <span class="fu">parseInteger</span>(<span class="st">&quot;123&quot;</span>);
<span class="kw">if</span>(aInt.<span class="fu">isPresent</span>()){
    <span class="fu">doSomething</span>(aInt.<span class="fu">get</span>());
} <span class="kw">else</span> {
    <span class="fu">doSomething</span>(<span class="dv">0</span>); <span class="co">// assume default value is 0.</span>
}</code></pre></div>
<p>这么写显得很笨重，如果 <code>Optional</code> 多嵌套基层，代码就很难看了。</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">Optional&lt;Double&gt; aDouble;
<span class="kw">if</span>(aInt.<span class="fu">isPresent</span>()){
    aDouble = <span class="fu">doSomethingWithInt</span>(aInt.<span class="fu">get</span>());
}<span class="kw">else</span> {
    aDouble = <span class="fu">doSomethingWithInt</span>(<span class="dv">0</span>);
}
<span class="kw">if</span>(aDouble.<span class="fu">isPresent</span>()){
    <span class="fu">doSomethingWithDouble</span>(aDouble.<span class="fu">get</span>());
}<span class="kw">else</span> {
    <span class="fu">doSomethingWithDouble</span>(<span class="fl">0.0</span>);
}</code></pre></div>
<p>我们可以改进一下</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"> Optional&lt;Double&gt; aDouble;
 Optional&lt;Double&gt; aDouble = <span class="fu">doSomethingWithInt</span>(aInt.<span class="fu">orElse</span>(<span class="dv">0</span>));
 <span class="fu">doSomethingWithDouble</span>(aDouble.<span class="fu">orElse</span>(<span class="fl">0.0</span>));</code></pre></div>
<p>也就是说，<code>orElse</code> 提供了缺省值的模式。</p>
<p>如果说缺省值模式，不适合，例如，业务逻辑的需求是如果解析成功，做某事，否则什么都不做。</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">if</span>(aInt.<span class="fu">isPresent</span>()){
    Optional&lt;Double&gt; aDouble = <span class="fu">doSomethingWithInt</span>(aInt.<span class="fu">get</span>(<span class="dv">0</span>));
    <span class="kw">if</span>(aDouble.<span class="fu">isPresent</span>()) {
        <span class="fu">doSomethingWithDouble</span>(aDouble.<span class="fu">get</span>());
    }
}</code></pre></div>
<p>可以想象，每判断一次，程序向右缩进一次，代码也很难看，我们可以改进一下。</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">aInt.<span class="fu">ifPresent</span>(aIntegerValue -&gt; {
    Optional&lt;Double&gt; aDouble = <span class="fu">doSomethingWithInt</span>(aIntegerValue);
    <span class="kw">return</span> aDouble.<span class="fu">ifPresent</span>(aDoubleValue -&gt;{
        <span class="fu">doSomethingWithDouble</span>(aDoubleValue);
    });
});</code></pre></div>
<p>我觉得这个很难称得上改进，但是 <code>ifPresent</code> 的确有应用的场景，我们换一个方式。</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">aInt.<span class="fu">flatMap</span>(YourClass::doSomethingWithInt)
    .<span class="fu">flatMap</span>(YourClass::doSomethingWithDouble)
    .<span class="fu">orElse</span>(aDefaultValue)</code></pre></div>
<p>注： <code>flatMap</code> 就是 haskell 里面 <code>bind</code> 操作符， <code>Optional</code> 对应的就是 <code>Maybe</code> Monad 。</p>
<p><code>flatMap</code> 很好的使用了这种模式。 <code>map</code> 有类似的操作。</p>
</article>
</main>
<span class="math"><script type="math/tex; mode=display"></script></span>
</body>
</html>
