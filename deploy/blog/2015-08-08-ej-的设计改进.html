<html>
  <head>
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
</script>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>ej 的设计改进</title>

  <link rel="stylesheet" href="../writ.min.css">
</head>
<body>
<main>
<header>
<h1>ej 的设计改进</h1>
<h3 class="date">2015/08/08 21:00:10</h3>
</header>
<article>
<p>根据 P426 &quot;erlang programming&quot; 的建议</p>
<ol style="list-style-type: decimal">
<li>只用很少的进程</li>
<li>进程只干真正需要并行干的事</li>
</ol>
<p>其中有一段</p>
<blockquote>
<p>If you are dealing with users logged in to a systerm, this probably not equate to a process for every session. Instead, you will have a process for every event entering the system.</p>
</blockquote>
<p>这样，我们可以有这样的设计</p>
<ul>
<li>一个主进程管理所有的连接</li>
<li>当有一个新的 tcp 数据包收到的时候
<ul>
<li>创建一个临时进程</li>
<li>转移 socket 的所有权给临时进程</li>
<li>转移状态给临时进程</li>
<li>临时进程处理消息</li>
<li>发送响应数据，注意，<code>gen_tcp:send</code> 也许会阻塞住</li>
<li>干完了，把状态和 socket 的控制权还给主进程。</li>
</ul></li>
<li>这个进程继续处理新的数据。保证快速响应用户数据</li>
</ul>
<p>优点</p>
<ul>
<li>可以防止悬空 socket 。
<ul>
<li>如果临时进程产生异常，将不会交还 Socket 回给主进程</li>
<li>如果临时进程出现意外，socket 讲自动关闭。</li>
</ul></li>
<li>关于连接的状态也被自动回收</li>
<li>socket 是 session 的唯一标识。</li>
<li>因为有很多的临时进程，可以防止 GC，因为快速结束的进程自动释放内存，不需要 GC 参与。</li>
<li>方便管理进程的生命期
<ul>
<li>两个互相协同工作（同生同死）的 <code>gen_server</code> 还不是很容易设计</li>
<li>要让他们都正常退出</li>
<li>如果不是正常退出，会产生 crash report</li>
</ul></li>
</ul>
<p>缺点</p>
<ul>
<li>需要频繁的拷贝状态，在主进程和临时进程之间。</li>
</ul>
<h2 id="tcp-链接的管理">tcp 链接的管理。</h2>
<p>见 https://github.com/wcy123/etcp_server</p>
<ul>
<li><code>etcp_listener_sup</code> 建立并管理监听进程。</li>
<li>监听进程创建一个临时工作进程。</li>
<li>工作进程等待监听进程通知。</li>
<li>监听进程等待新的 tcp 连接。</li>
</ul>
<p>当有新的 tcp 连接的时候</p>
<ul>
<li>监听进程要迅速恢复到监听状态
<ul>
<li>监听进程把 socket 控制权转移给临时工作进程</li>
<li>通知临时工作进程展开工作</li>
<li>启动新的临时工作进程，继续等待监听进程通知。</li>
<li>监听进程立刻重新进入监听状态。</li>
</ul></li>
<li>临时工作进程得到通知后
<ul>
<li>调用回调函数，创建/得到真正的工作进程</li>
<li>转移 socket 的控制权，给真正的工作进程。</li>
<li>发送 <code>become_controller</code> 给真正的工作进程</li>
<li>自己正常结束了。</li>
</ul></li>
</ul>
<h2 id="主进程的状态管理">主进程的状态管理</h2>
<p>参见 <code>benchmark</code> 的比较</p>
<ul>
<li><code>process dictionary</code></li>
<li><code>dict</code></li>
<li><code>ets</code></li>
<li><code>gb_tree</code></li>
<li><code>array</code></li>
</ul>
<p>最后胜出的是 <code>gb_tree</code></p>
<p>性能最快的是 <code>process dictionary</code> ，但是为啥不用呢</p>
<ul>
<li><code>process_info</code> 会拷贝 <code>process dictionary</code></li>
<li>很多远程调用 <code>Module:Function</code> 会调用，<code>process_info</code></li>
<li>产生大量不可预料的拷贝，所以，尽量不要使用 <code>process dictionary</code>。</li>
</ul>
<p>todo: 增加参考链接。</p>
<h2 id="协议栈的设计">协议栈的设计</h2>
<pre><code>  +------------------------------------+
  |    ej_c2s                          |
  +------------------------------------+
  |  ej_c2s_raw_transport(xml  stream) |
  +------------------------------------+
</code></pre>
<p>底层 transport layer 需要提供的服务有</p>
<ul>
<li><code>send(xml)</code></li>
<li>主动发送消息，xml stream</li>
</ul>
<h2 id="什么时候会生成-crash-reprot">什么时候会生成 crash reprot?</h2>
<p>参考 SASL 1.2.3 Crash report</p>
<p>如果使用 <code>proc_lib:spwarn</code> 或者 <code>proc_lib:spawn_link</code> 创建进程，那么进 程出现意外的时候会产生 crash report。</p>
<h2 id="会出现悬空-socket">会出现悬空 socket</h2>
<p>Socket 的控制权交还给主进程，但是 Socket 的状态是 <code>{active, false}</code> ， 所以 <code>tcp_closed</code> 的消息也收不到。</p>
<h3 id="解决方案-1">解决方案 1</h3>
<p>每当交还给主进程之后，都设置 <code>{active, once}</code>， 这样不行，因为在实现速 率控制的时候，也许客户不想这么快 active。</p>
<h3 id="解决方案-2">解决方案 2</h3>
<p>当控制权交还给主进程之后，检查 <code>{active, false}</code>， 如果是 false ，那么 就调用 <code>gen_tcp:recv</code> , timeout = 0。这样也不行。 如果对方没有关闭 tcp ，那么也不行。</p>
<h3 id="解决方案-3">解决方案 3</h3>
<p>定时检查所有 socket ，看是否有数据。这个是轮训的机制，效率低下。</p>
<h3 id="分析">分析</h3>
<p>产生这种问题的根本原因是 ”回调模块“ 没有处理好。似乎不能相信”回调“模块 会处理好。不能把控制 active 的权限给 ”回调“ 模块。 那么如何实现流控呢？ 提供 throttle 函数。</p>
<p>现在采用方案 1 ，以后再提供 throttle 函数。</p>
</article>
</main>
<span class="math"><script type="math/tex; mode=display"></script></span>
</body>
</html>
