<html>
  <head>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
      "HTML-CSS": {
      preferredFont: "STIX"
      },
      CommonHTML: {
      scale: 100
      },
      tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']]
      }});
</script>
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
</script>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>rxjava2 有什么新东西</title>

  <link rel="stylesheet" href="../writ.min.css">
</head>
<body>
<main>
<header>
<h1>rxjava2 有什么新东西</h1>
<h3 class="date">2017/01/07 20:18:14</h3>
</header>
<article>
<p>昨天看过Jakes Whaton 的一个视频 ，今天记录一下我脑子里还记得东西。也许不全，以后在仔细补全吧。</p>
<p>backpressure 怎么翻译，我翻译成流控吧。</p>
<p>rxjava1.x 里面最难的部分就是流控，我有一个文章专门分析了源代码，设计的不是很好。实现的也不是很好。</p>
<p>流控在 rxjava1.x 很晚期才引入的，所以一开始，并没有很好的设计。rxjava1.x 早期没有注意到流控的问题，后期发现有这个问题，于是引入了一些修改，而且这些修改很好的和原有的代码一起工作，就发版了。然而，流控是很难的东西，没有一个很好的设计，就会导致很多问题，不是所有的 source 和 operator 都意识到有流控这个东西，经常出现 MissingBackpressureException 。 就算 rxjava 1.x 自带的一些 operator 和 source 有的时候也会产生这个异常。rxjava1.x 里面的 <code>Obervable.create</code> 就不应该被任何人使用。这个　API 十分有用，而且十分强大，但是没有任何明确的说明，如何和流控一起好好的工作。</p>
<p>rxjava2.0 重新设计了接口。增加了对流控的重新设计。源代码层面上，完全重写了。</p>
<p>rxjava2.0 引入了 Flowable 这个类，基本上和 rxjava 1.0 的 Obserable 一样， 支持流控。</p>
<p>rxjava2.0 中的 Observable 类，则是完全不支持流控。这样大家可以随意使用 create 函数了。没有了流控，代码变得简单清晰，干净多了。</p>
<p>rxjava2.0 在类型系统上，支持显示的流控设计。Flowable 和 Obserable 不能互相混用，意思是说，源和操作符不能混用。Flowable 有自己的一套操作符和源，几乎和 Obserable 一模一样，但 Flowable 的操作符，不能用在 Observable 上，反之亦然。这样的好处就是，在代码的编译器，在类型检查阶段，就避免了流控的滥用。如果你有意识的使用流控，那么就用 Flowable ，否则就用 Obserable。有流控的操作符和没有流控的操作符，完全分开了。</p>
<p>Flowable 和 Observable 之间支持互相转换。这样我们在需要流控的地方，小心的使用 Flowable ，需要的时候，经过转换， Obserable 的世界，变得清楚多了。反之亦然，也可以把 Obserable 转换成为 Flowable 。转换的时候，我们需要显式的指明流控方式。</p>
<p>Rxjava2.0 里面不允许有 null 的数据。 null 是 java 的一个令人头疼的数据，任何对象，都有可能是 null ，这样违反了原来数据类型的语义。例如 Boolean 对象，本来要表示两种状态 ， true 和 false ，但是，其实他有三种状态，true, false, null 。所以代码逻辑上就很让人纠结。于是 Rxjava2.0 完全不允许 null 出现在数据流中。我想这是一个不小的改进。</p>
<p>但是如果我们需要表示有些对象是无效值怎么办？例如，我就是想表示某一个 Boolean 字段不是 true, 也不是 false，而是表示没有这个字段，网络协议中，经常发送者者为了节省带宽，有些可选字段就不发送。数据库里面，有些字段就是没有填写。rxjava 2.0 引入了 Maybe 这个类型，用来建模这种情况。</p>
<p>类似的，还有新类型 Single ，在类型系统上，保证语义上，一个产生一个单值。还有新类型 Completable ，在类型系统上，保证不会产生任何数据，仅仅产生 OnComplete 或者 OnError 。这种编译器的类型检查，防止代码错误出现在运行期，是一个很大的改进。</p>
<p>还与其他的一些改进，我记不住了，今天就写到这里吧。</p>
</article>
</main>
</body>
</html>
