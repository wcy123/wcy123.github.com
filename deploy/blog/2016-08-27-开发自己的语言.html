<html>
  <head>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
      "HTML-CSS": {
      preferredFont: "STIX"
      },
      CommonHTML: {
      scale: 100
      },
      tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']]
      }});
</script>
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
</script>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>开发自己的语言</title>

  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../writ.min.css">
</head>
<body>
<main>
<header>
<h1>开发自己的语言</h1>
<h3 class="date">2016/08/27 16:13:26</h3>
</header>
<article>
<!-- toc -->
<ul>
<li><a href="#原始类型">原始类型</a></li>
<li><a href="#quote">quote</a></li>
<li><a href="#if">if</a></li>
<li><a href="#代码块求值">代码块求值</a></li>
<li><a href="#函数的求值">函数的求值</a></li>
<li><a href="#函数调用与变量">函数调用与变量</a></li>
<li><a href="#内置函数">内置函数</a></li>
<li><a href="#定义变量define-和变量赋值set，还有-cond">定义变量(define) 和变量赋值(set!)，还有 cond</a></li>
</ul>
<!-- tocstop -->
<p>本文大多数参考 <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-25.html#%_chap_4">SICP</a></p>
<p>阴阳大法</p>
<div class="figure">
<img src="https://mitpress.mit.edu/sicp/full-text/book/ch4-Z-G-1.gif" alt="ying-yan" />
<p class="caption">ying-yan</p>
</div>
<p>一个语言的解释器，就是一个 eval 函数，就是求值函数：</p>
<ul>
<li>输入： 一个表达式 <code>s-exp</code></li>
<li>输出： 一个表达式 <code>s-exp</code></li>
</ul>
<p>这个解释器的核心就是 <code>apply</code> 和 <code>eval</code> 之间的互递归调用。</p>
<h2 id="原始类型">原始类型</h2>
<p>原始类型是一个 <code>s-exp</code> ，求值就是 <code>s-exp</code> 本身。包括：整数，浮点数，字符串。例如</p>
<pre><code>1  =&gt; 1
1.2 =&gt; 1.2
&quot;abc&quot; =&gt; &quot;abc&quot;</code></pre>
<p>这个规则看上去很简单，但是很重要，他是递归求值的终止条件。也就是说， <code>eval</code> 函数碰到这些原始类型的 <code>s-exp</code> ，不会递归调用 <code>apply</code> 。</p>
<p>根据这个规则，我们写一个函数</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> true </span><span class="dv">#t</span>)
(<span class="kw">define</span><span class="fu"> false </span><span class="dv">#f</span>)
(<span class="kw">define</span><span class="fu"> </span>(<span class="kw">eval</span> <span class="kw">exp</span> env)
  (<span class="kw">cond</span> ((self-evaluating? <span class="kw">exp</span>) <span class="kw">exp</span>)
        (<span class="kw">else</span> (error <span class="st">&quot;Unknown expression type -- EVAL&quot;</span> <span class="kw">exp</span>))))

(<span class="kw">define</span><span class="fu"> </span>(self-evaluating? <span class="kw">exp</span>)
  (<span class="kw">cond</span> ((<span class="kw">number?</span> <span class="kw">exp</span>) true)
        ((<span class="kw">string?</span> <span class="kw">exp</span>) true)
        (<span class="kw">else</span> false)))</code></pre></div>
<p>我们运行一下这个函数。首先我们需要安装一个 scheme 解释器，参考 <a href="https://github.com/cisco/ChezScheme" class="uri">https://github.com/cisco/ChezScheme</a> 语言参考 <a href="http://www.scheme.com/tspl4/" class="uri">http://www.scheme.com/tspl4/</a></p>
<pre><code>Chez Scheme Version 9.4
Copyright 1984-2016 Cisco Systems, Inc.

&gt; (load &quot;eval0.scm&quot;)
&gt; (eval 1 &#39;())
1
&gt; (eval 1.2 &#39;())
1.2
&gt; (eval &quot;abc&quot; &#39;())
&quot;abc&quot;
&gt; (eval (list 1 2 3) &#39;())
Exception in error: invalid message argument (1 2 3)
Type (debug) to enter the debugger.</code></pre>
<p>恭喜你，一个解释器的雏形开始了。这里有一个开发原则，“永远有一个可以工 作的版本”。我经历过两种开发模式。</p>
<ol style="list-style-type: decimal">
<li>写了一天的代码，从来没有编译运行过。然后花三天去调试。</li>
<li>写几分钟的代码，然后立即调试。循环往复，每次增加功能一点点。</li>
</ol>
<p>第一种模式下，大多数情况是，我自己思路不很清晰，模块还没有分解到足够细 致，所以一边写代码，一遍划分模块。</p>
<p>第二种模式下，我已经思路很清晰了，代码模块也很清晰了，尤其是模块划分的 颗粒度足够细致，脑子里面已经有具体的迭代步骤了。这种模式下，开发效率高 一些。</p>
<p>可以看到，<code>(eval (list 1 2 3) '()</code> 的时候，出现错误。这里也有一个开 发原则，“测试你的每一行代码”。可以看到，这几个简单的测试，覆盖了刚刚写 的所有代码。</p>
<p>开发初期，保证代码的测试覆盖率相对容易。这个时候，最好配合自动回归测试， 保证以后代码的覆盖率。如果开发初期没有把自动化测试做好，到了开后中后期， 在回过头来想保证代码的测试覆盖率，难度就十分大了。</p>
<p>好了，我们继续迭代开发我们的解释器。</p>
<h2 id="quote">quote</h2>
<p>这个规则也是一个终止条件。如果一个 <code>s-exp</code> 是一个 <code>list</code> ，第一个元素 是 <code>quote</code>，第二个元素任何一个 <code>s-exp</code> X，那么求值结果就是 X 。</p>
<pre><code>(quote 1) =&gt; 1
(quote 1.2) =&gt; 1.2
(quote &quot;abc&quot;) =&gt; &quot;abc
(quote (1 2 3)) =&gt; (1 2 3)
(quote a-symbol) =&gt; a-symbol
(quote quote) =&gt; quote</code></pre>
<p><code>s-exp</code> 中有一个重要的数据类型，就是 symbol 。 quote 可以得到 symbol 本身。</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(<span class="kw">eval</span> <span class="kw">exp</span> env)
  (<span class="kw">cond</span> (......
        ((quoted? <span class="kw">exp</span>) (text-of-quotation <span class="kw">exp</span>))
         ......
        (<span class="kw">else</span> (error <span class="st">&quot;Unknown expression type -- EVAL&quot;</span> <span class="kw">exp</span>))))</code></pre></div>
<p>我们看看 <code>quoted?</code> 和 <code>(text-of-quotation)</code> 怎么实现的？</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(quoted? <span class="kw">exp</span>)
  (tagged-list? <span class="kw">exp</span> &#39;quote))
(<span class="kw">define</span><span class="fu"> </span>(text-of-quotation <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(tagged-list? <span class="kw">exp</span> tag)
  (<span class="kw">if</span> (<span class="kw">pair?</span> <span class="kw">exp</span>)
      (<span class="kw">eq?</span> (<span class="kw">car</span> <span class="kw">exp</span>) tag)
      false))</code></pre></div>
<p>看看运行结果</p>
<pre><code>&gt; (load &quot;eval1.scm&quot;)
&gt; (eval &#39;(quote 1) &#39;())
1
&gt; (eval &#39;(quote 1.2) &#39;())
1.2
&gt; (eval &#39;(quote &quot;hello&quot;) &#39;())
&quot;hello&quot;
&gt; (eval &#39;(quote a-symbol) &#39;())
a-symbol
&gt; (eval &#39;(quote quote) &#39;())
quote</code></pre>
<p><code>eval1.scm</code> 的完整内容如下</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> true </span><span class="dv">#t</span>)
(<span class="kw">define</span><span class="fu"> false </span><span class="dv">#f</span>)
(<span class="kw">define</span><span class="fu"> </span>(<span class="kw">eval</span> <span class="kw">exp</span> env)
  (<span class="kw">cond</span> ((self-evaluating? <span class="kw">exp</span>) <span class="kw">exp</span>)
        ((quoted? <span class="kw">exp</span>) (text-of-quotation <span class="kw">exp</span>))
        (<span class="kw">else</span> (error <span class="st">&quot;Unknown expression type -- EVAL&quot;</span> <span class="kw">exp</span>))))

(<span class="kw">define</span><span class="fu"> </span>(self-evaluating? <span class="kw">exp</span>)
  (<span class="kw">cond</span> ((<span class="kw">number?</span> <span class="kw">exp</span>) true)
        ((<span class="kw">string?</span> <span class="kw">exp</span>) true)
        (<span class="kw">else</span> false)))

(<span class="kw">define</span><span class="fu"> </span>(quoted? <span class="kw">exp</span>)
  (tagged-list? <span class="kw">exp</span> &#39;quote))
(<span class="kw">define</span><span class="fu"> </span>(text-of-quotation <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(tagged-list? <span class="kw">exp</span> tag)
  (<span class="kw">if</span> (<span class="kw">pair?</span> <span class="kw">exp</span>)
      (<span class="kw">eq?</span> (<span class="kw">car</span> <span class="kw">exp</span>) tag)
      false))</code></pre></div>
<p>一个好的程序风格是，多写一些小的函数，然后组合这些函数。函数都有名字， 可以描述自己的作用。例如 <code>text-of-quotation</code> 。其实这个函数本质上和 <code>cadr</code> 没有任何区别。但是在逻辑层次上，<code>text-of-quotation</code> 是更加高层 的函数，<code>cadr</code> 是更加底层的函数。这种逻辑层次的划分，可以提高程序的可 读性。</p>
<h2 id="if">if</h2>
<p>支持条件表达式，输入 <code>s-exp</code> 是一个 list ，有四个元素：</p>
<ol style="list-style-type: decimal">
<li>第一个元素是 <code>if</code> ，表明是一个条件表达式。</li>
<li>第二个元素是判断条件 <code>&lt;C&gt;</code></li>
<li>第三个元素是 <code>&lt;T&gt;</code> 为真的时候，<code>s-exp</code> 的求值结果。</li>
<li>第三个元素是 <code>&lt;F&gt;</code> 为假的时候，<code>s-exp</code> 的求值结果。</li>
</ol>
<p>这里有一个语言设计的问题，是否有必要增加一个 boolean 的数据类型？什么 是真，什么是假？这里有很多让人难以捉摸的小细节。这个问题也是各种语言之 间争论很久的话题。为了简单，我们不在这个问题上展开讨论，我们不增加新的 数据类型，认为符号(symbol) <code>true</code> 是真，其他值都是假。</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(<span class="kw">eval</span> <span class="kw">exp</span> env)
  (<span class="kw">cond</span> (......
        ((if? <span class="kw">exp</span>) (eval-if <span class="kw">exp</span> env))
         ......
        (<span class="kw">else</span> (error <span class="st">&quot;Unknown expression type -- EVAL&quot;</span> <span class="kw">exp</span>))))</code></pre></div>
<p>先看看 <code>if?</code> 的实现。</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(if? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;if))</code></pre></div>
<p>感谢逻辑分层的代码风格，<code>if?</code> 的实现的可读性就很好了。</p>
<p>我们看看关键的 <code>eval-if</code> 怎么实现的。</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(eval-if <span class="kw">exp</span> env)
  (<span class="kw">if</span> (true? (<span class="kw">eval</span> (if-predicate <span class="kw">exp</span>) env))
      (<span class="kw">eval</span> (if-consequent <span class="kw">exp</span>) env)
      (<span class="kw">eval</span> (if-alternative <span class="kw">exp</span>) env)))</code></pre></div>
<p>这里有两点需要注意</p>
<ol style="list-style-type: decimal">
<li>递归调用， <code>eval-if</code> 递归调用了 <code>eval</code> ，可以看到递归调用的强大之处。</li>
<li>求值顺序。</li>
</ol>
<p>“求值顺序” 是一门语言的一个重大的设计问题。不同的求值顺序，导致完全不同 的效果。这里我们注意到，如果求值条件为真，那么假的分支是不做求值的。如 果求值条件为假，那么真的分支是不会求职的。这种设计叫做短路求值 (short-circuit)。 主流语言都是这么设计的。求值顺序是一个很重要的课题， 这里不展开讨论。</p>
<p>看看其他辅助函数如何实现的。这里再次应用了逻辑分层的代码风格。</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(if-predicate <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(if-consequent <span class="kw">exp</span>) (<span class="kw">caddr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(if-alternative <span class="kw">exp</span>)
  (<span class="kw">if</span> (<span class="kw">not</span> (<span class="kw">null?</span> (<span class="kw">cdddr</span> <span class="kw">exp</span>)))
      (<span class="kw">cadddr</span> <span class="kw">exp</span>)
      &#39;false))
(<span class="kw">define</span><span class="fu"> </span>(true? <span class="kw">exp</span>)
  (<span class="kw">eq?</span> <span class="kw">exp</span> &#39;true))</code></pre></div>
<p>我们看看程序的执行效果</p>
<pre><code>&gt; (eval &#39;(if (quote true) 1 2) &#39;())
1
&gt; (eval &#39;(if (quote false) 1 2) &#39;())
2</code></pre>
<p>非常好。 这里是完整的代码</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> true </span><span class="dv">#t</span>)
(<span class="kw">define</span><span class="fu"> false </span><span class="dv">#f</span>)
(<span class="kw">define</span><span class="fu"> </span>(<span class="kw">eval</span> <span class="kw">exp</span> env)
  (<span class="kw">cond</span> ((self-evaluating? <span class="kw">exp</span>) <span class="kw">exp</span>)
        ((quoted? <span class="kw">exp</span>) (text-of-quotation <span class="kw">exp</span>))
        ((if? <span class="kw">exp</span>) (eval-if <span class="kw">exp</span> env))
        (<span class="kw">else</span> (error <span class="st">&quot;Unknown expression type -- EVAL&quot;</span> <span class="kw">exp</span>))))

(<span class="kw">define</span><span class="fu"> </span>(self-evaluating? <span class="kw">exp</span>)
  (<span class="kw">cond</span> ((<span class="kw">number?</span> <span class="kw">exp</span>) true)
        ((<span class="kw">string?</span> <span class="kw">exp</span>) true)
        (<span class="kw">else</span> false)))
(<span class="kw">define</span><span class="fu"> </span>(if? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;if))

(<span class="kw">define</span><span class="fu"> </span>(eval-if <span class="kw">exp</span> env)
  (<span class="kw">if</span> (true? (<span class="kw">eval</span> (if-predicate <span class="kw">exp</span>) env))
      (<span class="kw">eval</span> (if-consequent <span class="kw">exp</span>) env)
      (<span class="kw">eval</span> (if-alternative <span class="kw">exp</span>) env)))

(<span class="kw">define</span><span class="fu"> </span>(if-predicate <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(if-consequent <span class="kw">exp</span>) (<span class="kw">caddr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(if-alternative <span class="kw">exp</span>)
  (<span class="kw">if</span> (<span class="kw">not</span> (<span class="kw">null?</span> (<span class="kw">cdddr</span> <span class="kw">exp</span>)))
      (<span class="kw">cadddr</span> <span class="kw">exp</span>)
      &#39;false))
(<span class="kw">define</span><span class="fu"> </span>(true? <span class="kw">exp</span>)
  (<span class="kw">eq?</span> <span class="kw">exp</span> &#39;true))

(<span class="kw">define</span><span class="fu"> </span>(quoted? <span class="kw">exp</span>)
  (tagged-list? <span class="kw">exp</span> &#39;quote))
(<span class="kw">define</span><span class="fu"> </span>(text-of-quotation <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(tagged-list? <span class="kw">exp</span> tag)
  (<span class="kw">if</span> (<span class="kw">pair?</span> <span class="kw">exp</span>)
      (<span class="kw">eq?</span> (<span class="kw">car</span> <span class="kw">exp</span>) tag)
      false))</code></pre></div>
<h2 id="代码块求值">代码块求值</h2>
<p>这个功能是一个很方便的功能。如果 <code>&lt;s-exp&gt;</code> 是下面的形式</p>
<pre><code>(begin &lt;E1&gt; &lt;E2&gt; .... &lt;En&gt;)</code></pre>
<p>那么我们对 E1 , E2 ，.... , En 分别求值，整个表达式的值就是 En 的求值结果。</p>
<pre><code>(define (eval exp env)
  (cond (.......
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ......</code></pre>
<p>看看关键函数 <code>eval-sequence</code> 的实现</p>
<pre><code>(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (eval (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))</code></pre>
<p>这里注意 1. 求值顺序 2. 递归调用 <code>eval</code> 3. 中间的表达式的求值结果被丢弃了</p>
<p>看看其他几个辅助函数的实现</p>
<pre><code>(define (begin? exp) (tagged-list? exp &#39;begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))</code></pre>
<p>看看程序的执行效果</p>
<pre><code>&gt; (load &quot;eval3.scm&quot;)
&gt; (eval &#39;(begin 1 2) &#39;())</code></pre>
<p>下面是完整的程序代码</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> true </span><span class="dv">#t</span>)
(<span class="kw">define</span><span class="fu"> false </span><span class="dv">#f</span>)
(<span class="kw">define</span><span class="fu"> </span>(<span class="kw">eval</span> <span class="kw">exp</span> env)
  (<span class="kw">cond</span> ((self-evaluating? <span class="kw">exp</span>) <span class="kw">exp</span>)
        ((quoted? <span class="kw">exp</span>) (text-of-quotation <span class="kw">exp</span>))
        ((if? <span class="kw">exp</span>) (eval-if <span class="kw">exp</span> env))
        ((begin? <span class="kw">exp</span>)
         (eval-sequence (begin-actions <span class="kw">exp</span>) env))
        (<span class="kw">else</span> (error <span class="st">&quot;Unknown expression type -- EVAL&quot;</span> <span class="kw">exp</span>))))

(<span class="kw">define</span><span class="fu"> </span>(self-evaluating? <span class="kw">exp</span>)
  (<span class="kw">cond</span> ((<span class="kw">number?</span> <span class="kw">exp</span>) true)
        ((<span class="kw">string?</span> <span class="kw">exp</span>) true)
        (<span class="kw">else</span> false)))
(<span class="kw">define</span><span class="fu"> </span>(if? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;if))

(<span class="kw">define</span><span class="fu"> </span>(eval-if <span class="kw">exp</span> env)
  (<span class="kw">if</span> (true? (<span class="kw">eval</span> (if-predicate <span class="kw">exp</span>) env))
      (<span class="kw">eval</span> (if-consequent <span class="kw">exp</span>) env)
      (<span class="kw">eval</span> (if-alternative <span class="kw">exp</span>) env)))

(<span class="kw">define</span><span class="fu"> </span>(if-predicate <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(if-consequent <span class="kw">exp</span>) (<span class="kw">caddr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(if-alternative <span class="kw">exp</span>)
  (<span class="kw">if</span> (<span class="kw">not</span> (<span class="kw">null?</span> (<span class="kw">cdddr</span> <span class="kw">exp</span>)))
      (<span class="kw">cadddr</span> <span class="kw">exp</span>)
      &#39;false))
(<span class="kw">define</span><span class="fu"> </span>(true? <span class="kw">exp</span>)
  (<span class="kw">eq?</span> <span class="kw">exp</span> &#39;true))

(<span class="kw">define</span><span class="fu"> </span>(eval-sequence exps env)
  (<span class="kw">cond</span> ((last-exp? exps) (<span class="kw">eval</span> (first-exp exps) env))
        (<span class="kw">else</span> (<span class="kw">eval</span> (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))

(<span class="kw">define</span><span class="fu"> </span>(begin? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;begin))
(<span class="kw">define</span><span class="fu"> </span>(begin-actions <span class="kw">exp</span>) (<span class="kw">cdr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(last-exp? seq) (<span class="kw">null?</span> (<span class="kw">cdr</span> seq)))
(<span class="kw">define</span><span class="fu"> </span>(first-exp seq) (<span class="kw">car</span> seq))
(<span class="kw">define</span><span class="fu"> </span>(rest-exps seq) (<span class="kw">cdr</span> seq))

(<span class="kw">define</span><span class="fu"> </span>(quoted? <span class="kw">exp</span>)
  (tagged-list? <span class="kw">exp</span> &#39;quote))
(<span class="kw">define</span><span class="fu"> </span>(text-of-quotation <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(tagged-list? <span class="kw">exp</span> tag)
  (<span class="kw">if</span> (<span class="kw">pair?</span> <span class="kw">exp</span>)
      (<span class="kw">eq?</span> (<span class="kw">car</span> <span class="kw">exp</span>) tag)
      false))</code></pre></div>
<h2 id="函数的求值">函数的求值</h2>
<p>什么是函数表达式，其实就是著名的 lambda 表达式。lambda 表达式格式如下</p>
<pre><code>(lambda &lt;PARAM-LIST&gt; &lt;FUN-BODY&gt;)</code></pre>
<p><code>PARAM-LIST</code> 是一个变量列表，引入变量的作用域，也叫环境。我们在求值 <code>FUN-BODY</code> 的时候，就在最内层的环境开始，有里向外的搜索变量。重名的时 候，内层变量先起作用，就这个就是所谓的阴影效果 (shadow) 。</p>
<p>求值一个 lambda 表达式的时候，返回值就是一个 “函数” 。</p>
<p>程序内部，如何表达一个函数呢？这也是一个重大的语言设计问题。编译型还是 解释型？目标语言的选择，字节码，还是机器码，还是其他的中间语言？</p>
<p>我们这个简单的语言中，我们就用 list 来表示。</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(make-procedure parameters body env)
   (<span class="kw">list</span> &#39;procedure parameters body env))
(<span class="kw">define</span><span class="fu"> </span>(procedure-parameters p) (<span class="kw">cadr</span> p))
(<span class="kw">define</span><span class="fu"> </span>(procedure-body p) (<span class="kw">caddr</span> p))
(<span class="kw">define</span><span class="fu"> </span>(procedure-environment p) (<span class="kw">cadddr</span> p))</code></pre></div>
<p>看看执行效果</p>
<pre><code>&gt; (make-procedure &#39;(a b) &#39;a &#39;())
(procedure (a b) a ())
&gt; (set! p1 (make-procedure &#39;(a b) &#39;a &#39;()))
&gt; (procedure-parameters  p1)
(a b)
&gt; (procedure-body  p1)
a
&gt; (procedure-env  p1)
&gt; (procedure-environment  p1)
()</code></pre>
<p>可见一个函数有三个元素，参数列表，函数体，和环境。环境这个概念一直没有 详细解释，再推到下面解释。</p>
<p>那么，我们先实现一个 lambda 表达式的解析。</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(<span class="kw">eval</span> <span class="kw">exp</span> env)
  (<span class="kw">cond</span> (.......
        ((lambda? <span class="kw">exp</span>)
         (make-procedure (lambda-parameters <span class="kw">exp</span>)
                         (lambda-body <span class="kw">exp</span>)
                         env))
        ......</code></pre></div>
<p>其他几个辅助函数的实现</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(lambda? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;lambda))
(<span class="kw">define</span><span class="fu"> </span>(lambda-parameters <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(lambda-body <span class="kw">exp</span>) (<span class="kw">cddr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(make-procedure parameters body env)
  (<span class="kw">list</span> &#39;procedure parameters body env))</code></pre></div>
<p>看看执行效果</p>
<pre><code>&gt; (lambda? &#39;(lambda 1))
#f
&gt; (lambda-parameters &#39;(lambda (a b) (+ a b)))
(a b)
&gt; (lambda-body &#39;(lambda (a b) (+ a b)))
((+ a b))
&gt; (make-procedure &#39;(a b) &#39;((+ a b)) &#39;())
(procedure (a b) ((+ a b)) ())
&gt; (eval &#39;(lambda (a b) (+ a b)) &#39;())
(procedure (a b) ((+ a b)) ())</code></pre>
<p>太好了，我们可以解析 lambda 表达式了。</p>
<p>这里是完整的代码</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> true </span><span class="dv">#t</span>)
(<span class="kw">define</span><span class="fu"> false </span><span class="dv">#f</span>)
(<span class="kw">define</span><span class="fu"> </span>(<span class="kw">eval</span> <span class="kw">exp</span> env)
  (<span class="kw">cond</span> ((self-evaluating? <span class="kw">exp</span>) <span class="kw">exp</span>)
        ((quoted? <span class="kw">exp</span>) (text-of-quotation <span class="kw">exp</span>))
        ((if? <span class="kw">exp</span>) (eval-if <span class="kw">exp</span> env))
        ((begin? <span class="kw">exp</span>)
         (eval-sequence (begin-actions <span class="kw">exp</span>) env))
        ((lambda? <span class="kw">exp</span>)
         (make-procedure (lambda-parameters <span class="kw">exp</span>)
                         (lambda-body <span class="kw">exp</span>)
                         env))
        (<span class="kw">else</span> (error <span class="st">&quot;Unknown expression type -- EVAL&quot;</span> <span class="kw">exp</span>))))

(<span class="kw">define</span><span class="fu"> </span>(self-evaluating? <span class="kw">exp</span>)
  (<span class="kw">cond</span> ((<span class="kw">number?</span> <span class="kw">exp</span>) true)
        ((<span class="kw">string?</span> <span class="kw">exp</span>) true)
        (<span class="kw">else</span> false)))
(<span class="kw">define</span><span class="fu"> </span>(if? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;if))

(<span class="kw">define</span><span class="fu"> </span>(eval-if <span class="kw">exp</span> env)
  (<span class="kw">if</span> (true? (<span class="kw">eval</span> (if-predicate <span class="kw">exp</span>) env))
      (<span class="kw">eval</span> (if-consequent <span class="kw">exp</span>) env)
      (<span class="kw">eval</span> (if-alternative <span class="kw">exp</span>) env)))

(<span class="kw">define</span><span class="fu"> </span>(if-predicate <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(if-consequent <span class="kw">exp</span>) (<span class="kw">caddr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(if-alternative <span class="kw">exp</span>)
  (<span class="kw">if</span> (<span class="kw">not</span> (<span class="kw">null?</span> (<span class="kw">cdddr</span> <span class="kw">exp</span>)))
      (<span class="kw">cadddr</span> <span class="kw">exp</span>)
      &#39;false))
(<span class="kw">define</span><span class="fu"> </span>(true? <span class="kw">exp</span>)
  (<span class="kw">eq?</span> <span class="kw">exp</span> &#39;true))

(<span class="kw">define</span><span class="fu"> </span>(lambda? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;lambda))
(<span class="kw">define</span><span class="fu"> </span>(lambda-parameters <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(lambda-body <span class="kw">exp</span>) (<span class="kw">cddr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(make-procedure parameters body env)
  (<span class="kw">list</span> &#39;procedure parameters body env))
(<span class="kw">define</span><span class="fu"> </span>(procedure-parameters p) (<span class="kw">cadr</span> p))
(<span class="kw">define</span><span class="fu"> </span>(procedure-body p) (<span class="kw">caddr</span> p))
(<span class="kw">define</span><span class="fu"> </span>(procedure-environment p) (<span class="kw">cadddr</span> p))

(<span class="kw">define</span><span class="fu"> </span>(eval-sequence exps env)
  (<span class="kw">cond</span> ((last-exp? exps) (<span class="kw">eval</span> (first-exp exps) env))
        (<span class="kw">else</span> (<span class="kw">eval</span> (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))

(<span class="kw">define</span><span class="fu"> </span>(begin? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;begin))
(<span class="kw">define</span><span class="fu"> </span>(begin-actions <span class="kw">exp</span>) (<span class="kw">cdr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(last-exp? seq) (<span class="kw">null?</span> (<span class="kw">cdr</span> seq)))
(<span class="kw">define</span><span class="fu"> </span>(first-exp seq) (<span class="kw">car</span> seq))
(<span class="kw">define</span><span class="fu"> </span>(rest-exps seq) (<span class="kw">cdr</span> seq))

(<span class="kw">define</span><span class="fu"> </span>(quoted? <span class="kw">exp</span>)
  (tagged-list? <span class="kw">exp</span> &#39;quote))
(<span class="kw">define</span><span class="fu"> </span>(text-of-quotation <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(tagged-list? <span class="kw">exp</span> tag)
  (<span class="kw">if</span> (<span class="kw">pair?</span> <span class="kw">exp</span>)
      (<span class="kw">eq?</span> (<span class="kw">car</span> <span class="kw">exp</span>) tag)
      false))</code></pre></div>
<h2 id="函数调用与变量">函数调用与变量</h2>
<p>刚刚我们定义了一个函数，但是并没有什么用处，我们看看什么是函数调用 (apply)。</p>
<pre><code>(&lt;L&gt; &lt;A1&gt; &lt;A2&gt; ... &lt;An&gt;)</code></pre>
<p>看看怎么解析这个函数调用型的 <code>s-exp</code> 。</p>
<ul>
<li>首先，<code>L</code> 是一个表达式，求值结果是一个函数</li>
<li>然后，<code>A1</code> 是一个表达式，求值结果是任意值</li>
<li>之后，依次求值 <code>A2</code> ... <code>An</code></li>
<li>之后，绑定 (bind) <code>A1</code> ... <code>An</code> 的值，到 <code>L</code> 的环境中。</li>
<li>最后，对 <code>L</code> 的函数体求值。并返回结果</li>
</ul>
<p>这里需要有两个注意的事项</p>
<ol style="list-style-type: decimal">
<li>求值顺序</li>
<li>递归调用</li>
<li>变量绑定</li>
</ol>
<p>这是一门语言最核心的部分了。求值顺序。我似乎提到求值顺序很多次了。这里 选择了大多数主流语言的设计。</p>
<p>参数的求值顺序也很重要，有的语言为了性能，不定义参数的求值顺序。</p>
<p>第二个问题就是阴阳大法的互递归调用。apply 不停地调用 eval 得到函数对象， 和参数，绑定参数，然后调用 eval 求值函数体。而 apply 的处理，正式 eval 函数中的重要组成部分。</p>
<p>第三个问题就是变量的作用域的问题。变量的作用域也是一个重大的语言设计问 题。不同的语言有不同的设计，展现了不同语言丰富的表达能力。现在主流语言 是“词法作用域” (lexical scope) 。我们选择的是一个简单的词法作用域的实 现。</p>
<p>这里也需要注意参数的求值环境是在当前环境，而函数体的求值环境，是参数绑 定之后的新环境。</p>
<p>什么是求值环境？求值环境就是一个变量名称到变量值的映射关系。</p>
<p>什么是闭包(closure) ? 闭包也是一个环境，就是在生成一个函数的时候，当时 的环境。</p>
<p>什么是帧 (frame) ? 就是函数调用的时候，绑定参数生成的环境。</p>
<p>这就是说环境是一个动态的数状结构（递归结构）。在求值一个函数的函数体的 时候，碰到变量求值，会递归搜索闭包，这样除了参数绑定产生的本地环境之外， 还需要搜索闭包。</p>
<p>我们先实现 frame 。</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(make-frame variables <span class="kw">values</span>)
  (<span class="kw">cons</span> variables <span class="kw">values</span>))
(<span class="kw">define</span><span class="fu"> </span>(frame-variables frame) (<span class="kw">car</span> frame))
(<span class="kw">define</span><span class="fu"> </span>(frame-values frame) (<span class="kw">cdr</span> frame))</code></pre></div>
<p>看看运行效果</p>
<pre><code>&gt; (set! f1 (make-frame &#39;(a b c) &#39;(1 2 3)))
&gt; (frame-variables f1)
(a b c)
&gt; (frame-values f1)
(1 2 3)</code></pre>
<p>我们再实现 env 。</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(extend-environment vars vals base-env)
  (<span class="kw">if</span> (<span class="kw">=</span> (<span class="kw">length</span> vars) (<span class="kw">length</span> vals))
      (<span class="kw">cons</span> (make-frame vars vals) base-env)
      (<span class="kw">if</span> (<span class="kw">&lt;</span> (<span class="kw">length</span> vars) (<span class="kw">length</span> vals))
          (error <span class="st">&quot;Too many arguments supplied&quot;</span> vars vals)
          (error <span class="st">&quot;Too few arguments supplied&quot;</span> vars vals))))
(<span class="kw">define</span><span class="fu"> </span>(enclosing-environment env) (<span class="kw">cdr</span> env))
(<span class="kw">define</span><span class="fu"> </span>(first-frame env) (<span class="kw">car</span> env))
(<span class="kw">define</span><span class="fu"> the-empty-environment </span>&#39;())</code></pre></div>
<p>看看执行效果</p>
<pre><code>&gt; (set! e1 (extend-environment &#39;(a b c) &#39;(1 2 3) the-empty-environment)))
&gt; e1
(((a b c) 1 2 3))
&gt; (enclosing-environment e1)
()
&gt; (set! e2 (extend-environment &#39;(x y z) &#39;(10 20 30) e1))
&gt; e2
(((x y z) 10 20 30) ((a b c) 1 2 3))
&gt; (enclosing-environment e2)
(((a b c) 1 2 3))</code></pre>
<p>我们再实现一个变量查找的功能</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(lookup-variable-value var env)
  (<span class="kw">define</span><span class="fu"> </span>(env-loop env)
    (<span class="kw">define</span><span class="fu"> </span>(scan vars vals)
      (<span class="kw">cond</span> ((<span class="kw">null?</span> vars)
             (env-loop (enclosing-environment env)))
            ((<span class="kw">eq?</span> var (<span class="kw">car</span> vars))
             (<span class="kw">car</span> vals))
            (<span class="kw">else</span> (scan (<span class="kw">cdr</span> vars) (<span class="kw">cdr</span> vals)))))
    (<span class="kw">if</span> (<span class="kw">eq?</span> env the-empty-environment)
        (error <span class="st">&quot;Unbound variable&quot;</span> var)
        (<span class="kw">let</span> ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))</code></pre></div>
<p>我们看看执行效果</p>
<pre><code>&gt; (lookup-variable-value &#39;x e2)
10
&gt; (lookup-variable-value &#39;y e2)
20
&gt; (lookup-variable-value &#39;a e1)
1
&gt; (lookup-variable-value &#39;a e2)
1
&gt; (lookup-variable-value &#39;u e2)
Exception: Unbound variable with irritant u
Type (debug) to enter the debugger.</code></pre>
<p>有了这些，我们可以实现变量的求值了。</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(<span class="kw">eval</span> <span class="kw">exp</span> env)
  (<span class="kw">cond</span> (.......
        ((variable? <span class="kw">exp</span>) (lookup-variable-value <span class="kw">exp</span> env))
        ......</code></pre></div>
<p>看看执行效果</p>
<pre><code>&gt; (eval &#39;a e1)
1
&gt; (eval &#39;b e1)
2
&gt; (eval &#39;c e1)
3
&gt; (eval &#39;a e2)
1
&gt; (eval &#39;b e2)
2
&gt; (eval &#39;c e2)
3
&gt; (eval &#39;x e2)
10
&gt; (eval &#39;y e2)
20
&gt; (eval &#39;z e2)
30</code></pre>
<p>辅助函数的实现</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(variable? <span class="kw">exp</span>) (<span class="kw">symbol?</span> <span class="kw">exp</span>))</code></pre></div>
<p>我们继续，有了这些，我们可以实现 apply 的解析了</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(<span class="kw">eval</span> <span class="kw">exp</span> env)
  (<span class="kw">cond</span> (.......
        ((application? <span class="kw">exp</span>)
         (apply (<span class="kw">eval</span> (operator <span class="kw">exp</span>) env)
                   (list-of-values (operands <span class="kw">exp</span>) env)))
        ......</code></pre></div>
<p>看看一些辅助函数的实现</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(application? <span class="kw">exp</span>) (<span class="kw">pair?</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(operator <span class="kw">exp</span>) (<span class="kw">car</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(operands <span class="kw">exp</span>) (<span class="kw">cdr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(no-operands? ops) (<span class="kw">null?</span> ops))
(<span class="kw">define</span><span class="fu"> </span>(first-operand ops) (<span class="kw">car</span> ops))
(<span class="kw">define</span><span class="fu"> </span>(rest-operands ops) (<span class="kw">cdr</span> ops))
(<span class="kw">define</span><span class="fu"> </span>(list-of-values exps env)
  (<span class="kw">if</span> (no-operands? exps)
      &#39;()
      (<span class="kw">cons</span> (<span class="kw">eval</span> (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))</code></pre></div>
<p>看看执行效果</p>
<pre><code>&gt; (eval &#39;((lambda (a b) a) 1 2) &#39;())
1
&gt; (eval &#39;((lambda (a b) b) 1 2) &#39;())
2
&gt;</code></pre>
<p>下面是完整的代码</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> true </span><span class="dv">#t</span>)
(<span class="kw">define</span><span class="fu"> false </span><span class="dv">#f</span>)
(<span class="kw">define</span><span class="fu"> </span>(<span class="kw">eval</span> <span class="kw">exp</span> env)
  (<span class="kw">cond</span> ((self-evaluating? <span class="kw">exp</span>) <span class="kw">exp</span>)
        ((quoted? <span class="kw">exp</span>) (text-of-quotation <span class="kw">exp</span>))
        ((if? <span class="kw">exp</span>) (eval-if <span class="kw">exp</span> env))
        ((begin? <span class="kw">exp</span>)
         (eval-sequence (begin-actions <span class="kw">exp</span>) env))
        ((lambda? <span class="kw">exp</span>)
         (make-procedure (lambda-parameters <span class="kw">exp</span>)
                         (lambda-body <span class="kw">exp</span>)
                         env))
        ((variable? <span class="kw">exp</span>) (lookup-variable-value <span class="kw">exp</span> env))
        ((application? <span class="kw">exp</span>)
         (apply (<span class="kw">eval</span> (operator <span class="kw">exp</span>) env)
                   (list-of-values (operands <span class="kw">exp</span>) env)))
        (<span class="kw">else</span> (error <span class="dv">#f</span> <span class="st">&quot;Unknown expression type -- EVAL&quot;</span> <span class="kw">exp</span>))))

(<span class="kw">define</span><span class="fu"> </span>(self-evaluating? <span class="kw">exp</span>)
  (<span class="kw">cond</span> ((<span class="kw">number?</span> <span class="kw">exp</span>) true)
        ((<span class="kw">string?</span> <span class="kw">exp</span>) true)
        (<span class="kw">else</span> false)))
(<span class="kw">define</span><span class="fu"> </span>(if? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;if))

(<span class="kw">define</span><span class="fu"> </span>(eval-if <span class="kw">exp</span> env)
  (<span class="kw">if</span> (true? (<span class="kw">eval</span> (if-predicate <span class="kw">exp</span>) env))
      (<span class="kw">eval</span> (if-consequent <span class="kw">exp</span>) env)
      (<span class="kw">eval</span> (if-alternative <span class="kw">exp</span>) env)))

(<span class="kw">define</span><span class="fu"> </span>(if-predicate <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(if-consequent <span class="kw">exp</span>) (<span class="kw">caddr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(if-alternative <span class="kw">exp</span>)
  (<span class="kw">if</span> (<span class="kw">not</span> (<span class="kw">null?</span> (<span class="kw">cdddr</span> <span class="kw">exp</span>)))
      (<span class="kw">cadddr</span> <span class="kw">exp</span>)
      &#39;false))
(<span class="kw">define</span><span class="fu"> </span>(true? <span class="kw">exp</span>)
  (<span class="kw">eq?</span> <span class="kw">exp</span> &#39;true))

(<span class="kw">define</span><span class="fu"> </span>(lambda? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;lambda))
(<span class="kw">define</span><span class="fu"> </span>(lambda-parameters <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(lambda-body <span class="kw">exp</span>) (<span class="kw">cddr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(make-procedure parameters body env)
  (<span class="kw">list</span> &#39;procedure parameters body env))
(<span class="kw">define</span><span class="fu"> </span>(procedure-parameters p) (<span class="kw">cadr</span> p))
(<span class="kw">define</span><span class="fu"> </span>(procedure-body p) (<span class="kw">caddr</span> p))
(<span class="kw">define</span><span class="fu"> </span>(procedure-environment p) (<span class="kw">cadddr</span> p))


(<span class="kw">define</span><span class="fu"> </span>(apply procedure arguments)
  (eval-sequence
   (procedure-body procedure)
   (extend-environment
    (procedure-parameters procedure)
    arguments
    (procedure-environment procedure))))

(<span class="kw">define</span><span class="fu"> </span>(extend-environment vars vals base-env)
  (<span class="kw">if</span> (<span class="kw">=</span> (<span class="kw">length</span> vars) (<span class="kw">length</span> vals))
      (<span class="kw">cons</span> (make-frame vars vals) base-env)
      (<span class="kw">if</span> (<span class="kw">&lt;</span> (<span class="kw">length</span> vars) (<span class="kw">length</span> vals))
          (error <span class="st">&quot;Too many arguments supplied&quot;</span> vars vals)
          (error <span class="st">&quot;Too few arguments supplied&quot;</span> vars vals))))

(<span class="kw">define</span><span class="fu"> </span>(make-frame variables <span class="kw">values</span>)
  (<span class="kw">cons</span> variables <span class="kw">values</span>))
(<span class="kw">define</span><span class="fu"> </span>(frame-variables frame) (<span class="kw">car</span> frame))
(<span class="kw">define</span><span class="fu"> </span>(frame-values frame) (<span class="kw">cdr</span> frame))

(<span class="kw">define</span><span class="fu"> </span>(extend-environment vars vals base-env)
  (<span class="kw">if</span> (<span class="kw">=</span> (<span class="kw">length</span> vars) (<span class="kw">length</span> vals))
      (<span class="kw">cons</span> (make-frame vars vals) base-env)
      (<span class="kw">if</span> (<span class="kw">&lt;</span> (<span class="kw">length</span> vars) (<span class="kw">length</span> vals))
          (error <span class="st">&quot;Too many arguments supplied&quot;</span> vars vals)
          (error <span class="st">&quot;Too few arguments supplied&quot;</span> vars vals))))
(<span class="kw">define</span><span class="fu"> </span>(enclosing-environment env) (<span class="kw">cdr</span> env))
(<span class="kw">define</span><span class="fu"> </span>(first-frame env) (<span class="kw">car</span> env))
(<span class="kw">define</span><span class="fu"> the-empty-environment </span>&#39;())
(<span class="kw">define</span><span class="fu"> </span>(lookup-variable-value var env)
  (<span class="kw">define</span><span class="fu"> </span>(env-loop env)
    (<span class="kw">define</span><span class="fu"> </span>(scan vars vals)
      (<span class="kw">cond</span> ((<span class="kw">null?</span> vars)
             (env-loop (enclosing-environment env)))
            ((<span class="kw">eq?</span> var (<span class="kw">car</span> vars))
             (<span class="kw">car</span> vals))
            (<span class="kw">else</span> (scan (<span class="kw">cdr</span> vars) (<span class="kw">cdr</span> vals)))))
    (<span class="kw">if</span> (<span class="kw">eq?</span> env the-empty-environment)
        (error <span class="dv">#f</span> <span class="st">&quot;Unbound variable&quot;</span> var)
        (<span class="kw">let</span> ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(<span class="kw">define</span><span class="fu"> </span>(variable? <span class="kw">exp</span>) (<span class="kw">symbol?</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(application? <span class="kw">exp</span>) (<span class="kw">pair?</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(operator <span class="kw">exp</span>) (<span class="kw">car</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(operands <span class="kw">exp</span>) (<span class="kw">cdr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(no-operands? ops) (<span class="kw">null?</span> ops))
(<span class="kw">define</span><span class="fu"> </span>(first-operand ops) (<span class="kw">car</span> ops))
(<span class="kw">define</span><span class="fu"> </span>(rest-operands ops) (<span class="kw">cdr</span> ops))
(<span class="kw">define</span><span class="fu"> </span>(list-of-values exps env)
  (<span class="kw">if</span> (no-operands? exps)
      &#39;()
      (<span class="kw">cons</span> (<span class="kw">eval</span> (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(<span class="kw">define</span><span class="fu"> </span>(eval-sequence exps env)
  (<span class="kw">cond</span> ((last-exp? exps) (<span class="kw">eval</span> (first-exp exps) env))
        (<span class="kw">else</span> (<span class="kw">eval</span> (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))

(<span class="kw">define</span><span class="fu"> </span>(begin? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;begin))
(<span class="kw">define</span><span class="fu"> </span>(begin-actions <span class="kw">exp</span>) (<span class="kw">cdr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(last-exp? seq) (<span class="kw">null?</span> (<span class="kw">cdr</span> seq)))
(<span class="kw">define</span><span class="fu"> </span>(first-exp seq) (<span class="kw">car</span> seq))
(<span class="kw">define</span><span class="fu"> </span>(rest-exps seq) (<span class="kw">cdr</span> seq))

(<span class="kw">define</span><span class="fu"> </span>(quoted? <span class="kw">exp</span>)
  (tagged-list? <span class="kw">exp</span> &#39;quote))
(<span class="kw">define</span><span class="fu"> </span>(text-of-quotation <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(tagged-list? <span class="kw">exp</span> tag)
  (<span class="kw">if</span> (<span class="kw">pair?</span> <span class="kw">exp</span>)
      (<span class="kw">eq?</span> (<span class="kw">car</span> <span class="kw">exp</span>) tag)
      false))</code></pre></div>
<h2 id="内置函数">内置函数</h2>
<p>我们有了语言的核心，但是这个语言还没什么用，因为连基本的加减乘除都做不 了。我们利用宿主语言提供的功能，实现一些基本的内置函数。</p>
<p>首先我们要区分内置函数和语言自己的函数。我们用 <code>primitive</code> 来标记内置函数。</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(primitive-procedure? proc)
  (tagged-list? proc &#39;primitive))</code></pre></div>
<p>primitive 函数有一个属性，就是底层的函数实现。</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(primitive-implementation proc) (<span class="kw">cadr</span> proc))</code></pre></div>
<p>我们预先定义下面这些内置函数</p>
<pre><code>(define primitive-procedures
  (list (list &#39;car car)
        (list &#39;cdr cdr)
        (list &#39;cons cons)
        (list &#39;null? null?)
...
        ))</code></pre>
<p>我们初始化语言的初始环境</p>
<pre><code>(define (primitive-procedure-names)
  (map car
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list &#39;primitive (cadr proc)))
  primitive-procedures))
(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    initial-env))
(define the-global-environment (setup-environment))</code></pre>
<p>看看执行效果</p>
<pre><code>&gt; (load &quot;eval6.scm&quot;)
&gt; the-global-environment
(((car cdr cons null?)
   (primitive #&lt;procedure car&gt;)
   (primitive #&lt;procedure cdr&gt;)
   (primitive #&lt;procedure cons&gt;)
   (primitive #&lt;procedure null?&gt;)))</code></pre>
<p>对应的 <code>apply</code> 函数需要修改，这样才能调用内置函数。</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(apply procedure arguments)
  (<span class="kw">cond</span> ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
           (procedure-body procedure)
           (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
        (<span class="kw">else</span>
         (error
          <span class="st">&quot;Unknown procedure type -- APPLY&quot;</span> procedure))))</code></pre></div>
<p>看看其他几个辅助函数的实现</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(compound-procedure? p) (tagged-list? p &#39;procedure))
(<span class="kw">define</span><span class="fu"> </span>(apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))
(<span class="kw">define</span><span class="fu"> apply-in-underlying-scheme </span>apply)</code></pre></div>
<p>看看执行效果</p>
<pre><code>&gt; (eval &#39;car the-global-environment)
(primitive #&lt;procedure car&gt;)
&gt; (apply-primitive-procedure (eval &#39;car the-global-environment) &#39;((1 2)))
1
&gt; (eval &#39;(car &#39;(1 2)) the-global-environment)
1
&gt; (eval &#39;(display &quot;hello world&quot;) the-global-environment)
hello world
&gt;</code></pre>
<p>这里有一个坑，<code>apply</code> 已经在宿主语言中有定义了，所有我们要换一个名字， 防止名字冲突。并且用 <code>apply-primitive-procedure</code> 强调我们调用的是宿主 语言的 apply 函数。</p>
<pre><code>(define apply-in-underlying-scheme (top-level-value &#39;apply (scheme-environment)))</code></pre>
<p>我们的语言居然可以输出 &quot;hello world&quot; 了。下面是完整的代码。</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> apply-in-underlying-scheme </span>(top-level-value &#39;apply (scheme-environment)))
(<span class="kw">define</span><span class="fu"> true </span><span class="dv">#t</span>)
(<span class="kw">define</span><span class="fu"> false </span><span class="dv">#f</span>)
(<span class="kw">define</span><span class="fu"> </span>(<span class="kw">eval</span> <span class="kw">exp</span> env)
  (<span class="kw">cond</span> ((self-evaluating? <span class="kw">exp</span>) <span class="kw">exp</span>)
        ((quoted? <span class="kw">exp</span>) (text-of-quotation <span class="kw">exp</span>))
        ((if? <span class="kw">exp</span>) (eval-if <span class="kw">exp</span> env))
        ((begin? <span class="kw">exp</span>)
         (eval-sequence (begin-actions <span class="kw">exp</span>) env))
        ((lambda? <span class="kw">exp</span>)
         (make-procedure (lambda-parameters <span class="kw">exp</span>)
                         (lambda-body <span class="kw">exp</span>)
                         env))
        ((variable? <span class="kw">exp</span>) (lookup-variable-value <span class="kw">exp</span> env))
        ((application? <span class="kw">exp</span>)
         (apply (<span class="kw">eval</span> (operator <span class="kw">exp</span>) env)
                   (list-of-values (operands <span class="kw">exp</span>) env)))
        (<span class="kw">else</span> (error <span class="dv">#f</span> <span class="st">&quot;Unknown expression type -- EVAL&quot;</span> <span class="kw">exp</span>))))

(<span class="kw">define</span><span class="fu"> </span>(self-evaluating? <span class="kw">exp</span>)
  (<span class="kw">cond</span> ((<span class="kw">number?</span> <span class="kw">exp</span>) true)
        ((<span class="kw">string?</span> <span class="kw">exp</span>) true)
        (<span class="kw">else</span> false)))
(<span class="kw">define</span><span class="fu"> </span>(if? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;if))

(<span class="kw">define</span><span class="fu"> </span>(eval-if <span class="kw">exp</span> env)
  (<span class="kw">if</span> (true? (<span class="kw">eval</span> (if-predicate <span class="kw">exp</span>) env))
      (<span class="kw">eval</span> (if-consequent <span class="kw">exp</span>) env)
      (<span class="kw">eval</span> (if-alternative <span class="kw">exp</span>) env)))

(<span class="kw">define</span><span class="fu"> </span>(if-predicate <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(if-consequent <span class="kw">exp</span>) (<span class="kw">caddr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(if-alternative <span class="kw">exp</span>)
  (<span class="kw">if</span> (<span class="kw">not</span> (<span class="kw">null?</span> (<span class="kw">cdddr</span> <span class="kw">exp</span>)))
      (<span class="kw">cadddr</span> <span class="kw">exp</span>)
      &#39;false))
(<span class="kw">define</span><span class="fu"> </span>(true? <span class="kw">exp</span>)
  (<span class="kw">eq?</span> <span class="kw">exp</span> &#39;true))

(<span class="kw">define</span><span class="fu"> </span>(lambda? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;lambda))
(<span class="kw">define</span><span class="fu"> </span>(lambda-parameters <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(lambda-body <span class="kw">exp</span>) (<span class="kw">cddr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(make-procedure parameters body env)
  (<span class="kw">list</span> &#39;procedure parameters body env))
(<span class="kw">define</span><span class="fu"> </span>(compound-procedure? p) (tagged-list? p &#39;procedure))
(<span class="kw">define</span><span class="fu"> </span>(procedure-parameters p) (<span class="kw">cadr</span> p))
(<span class="kw">define</span><span class="fu"> </span>(procedure-body p) (<span class="kw">caddr</span> p))
(<span class="kw">define</span><span class="fu"> </span>(procedure-environment p) (<span class="kw">cadddr</span> p))

(<span class="kw">define</span><span class="fu"> </span>(apply procedure arguments)
  (<span class="kw">cond</span> ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
           (procedure-body procedure)
           (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
        (<span class="kw">else</span>
         (error
          <span class="st">&quot;Unknown procedure type -- APPLY&quot;</span> procedure))))

(<span class="kw">define</span><span class="fu"> </span>(extend-environment vars vals base-env)
  (<span class="kw">if</span> (<span class="kw">=</span> (<span class="kw">length</span> vars) (<span class="kw">length</span> vals))
      (<span class="kw">cons</span> (make-frame vars vals) base-env)
      (<span class="kw">if</span> (<span class="kw">&lt;</span> (<span class="kw">length</span> vars) (<span class="kw">length</span> vals))
          (error <span class="st">&quot;Too many arguments supplied&quot;</span> vars vals)
          (error <span class="st">&quot;Too few arguments supplied&quot;</span> vars vals))))

(<span class="kw">define</span><span class="fu"> </span>(make-frame variables <span class="kw">values</span>)
  (<span class="kw">cons</span> variables <span class="kw">values</span>))
(<span class="kw">define</span><span class="fu"> </span>(frame-variables frame) (<span class="kw">car</span> frame))
(<span class="kw">define</span><span class="fu"> </span>(frame-values frame) (<span class="kw">cdr</span> frame))

(<span class="kw">define</span><span class="fu"> </span>(extend-environment vars vals base-env)
  (<span class="kw">if</span> (<span class="kw">=</span> (<span class="kw">length</span> vars) (<span class="kw">length</span> vals))
      (<span class="kw">cons</span> (make-frame vars vals) base-env)
      (<span class="kw">if</span> (<span class="kw">&lt;</span> (<span class="kw">length</span> vars) (<span class="kw">length</span> vals))
          (error <span class="st">&quot;Too many arguments supplied&quot;</span> vars vals)
          (error <span class="st">&quot;Too few arguments supplied&quot;</span> vars vals))))
(<span class="kw">define</span><span class="fu"> </span>(enclosing-environment env) (<span class="kw">cdr</span> env))
(<span class="kw">define</span><span class="fu"> </span>(first-frame env) (<span class="kw">car</span> env))
(<span class="kw">define</span><span class="fu"> the-empty-environment </span>&#39;())
(<span class="kw">define</span><span class="fu"> </span>(lookup-variable-value var env)
  (<span class="kw">define</span><span class="fu"> </span>(env-loop env)
    (<span class="kw">define</span><span class="fu"> </span>(scan vars vals)
      (<span class="kw">cond</span> ((<span class="kw">null?</span> vars)
             (env-loop (enclosing-environment env)))
            ((<span class="kw">eq?</span> var (<span class="kw">car</span> vars))
             (<span class="kw">car</span> vals))
            (<span class="kw">else</span> (scan (<span class="kw">cdr</span> vars) (<span class="kw">cdr</span> vals)))))
    (<span class="kw">if</span> (<span class="kw">eq?</span> env the-empty-environment)
        (error <span class="dv">#f</span> <span class="st">&quot;Unbound variable&quot;</span> var)
        (<span class="kw">let</span> ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
(<span class="kw">define</span><span class="fu"> </span>(primitive-procedure? proc)
  (tagged-list? proc &#39;primitive))
(<span class="kw">define</span><span class="fu"> primitive-procedures</span>
  (<span class="kw">list</span> (<span class="kw">list</span> &#39;car <span class="kw">car</span>)
        (<span class="kw">list</span> &#39;cdr <span class="kw">cdr</span>)
        (<span class="kw">list</span> &#39;cons <span class="kw">cons</span>)
        (<span class="kw">list</span> &#39;null? <span class="kw">null?</span>)
        (<span class="kw">list</span> &#39;display <span class="kw">display</span>)
        ))
(<span class="kw">define</span><span class="fu"> </span>(primitive-implementation proc) (<span class="kw">cadr</span> proc))
(<span class="kw">define</span><span class="fu"> </span>(primitive-procedure-names)
  (map <span class="kw">car</span>
       primitive-procedures))
(<span class="kw">define</span><span class="fu"> </span>(apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))


(<span class="kw">define</span><span class="fu"> </span>(primitive-procedure-objects)
  (map (<span class="kw">lambda</span> (proc) (<span class="kw">list</span> &#39;primitive (<span class="kw">cadr</span> proc)))
       primitive-procedures))
(<span class="kw">define</span><span class="fu"> </span>(setup-environment)
  (<span class="kw">let</span> ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    initial-env))
(<span class="kw">define</span><span class="fu"> the-global-environment </span>(setup-environment))

(<span class="kw">define</span><span class="fu"> </span>(variable? <span class="kw">exp</span>) (<span class="kw">symbol?</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(application? <span class="kw">exp</span>) (<span class="kw">pair?</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(operator <span class="kw">exp</span>) (<span class="kw">car</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(operands <span class="kw">exp</span>) (<span class="kw">cdr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(no-operands? ops) (<span class="kw">null?</span> ops))
(<span class="kw">define</span><span class="fu"> </span>(first-operand ops) (<span class="kw">car</span> ops))
(<span class="kw">define</span><span class="fu"> </span>(rest-operands ops) (<span class="kw">cdr</span> ops))
(<span class="kw">define</span><span class="fu"> </span>(list-of-values exps env)
  (<span class="kw">if</span> (no-operands? exps)
      &#39;()
      (<span class="kw">cons</span> (<span class="kw">eval</span> (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(<span class="kw">define</span><span class="fu"> </span>(eval-sequence exps env)
  (<span class="kw">cond</span> ((last-exp? exps) (<span class="kw">eval</span> (first-exp exps) env))
        (<span class="kw">else</span> (<span class="kw">eval</span> (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))

(<span class="kw">define</span><span class="fu"> </span>(begin? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;begin))
(<span class="kw">define</span><span class="fu"> </span>(begin-actions <span class="kw">exp</span>) (<span class="kw">cdr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(last-exp? seq) (<span class="kw">null?</span> (<span class="kw">cdr</span> seq)))
(<span class="kw">define</span><span class="fu"> </span>(first-exp seq) (<span class="kw">car</span> seq))
(<span class="kw">define</span><span class="fu"> </span>(rest-exps seq) (<span class="kw">cdr</span> seq))

(<span class="kw">define</span><span class="fu"> </span>(quoted? <span class="kw">exp</span>)
  (tagged-list? <span class="kw">exp</span> &#39;quote))
(<span class="kw">define</span><span class="fu"> </span>(text-of-quotation <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(tagged-list? <span class="kw">exp</span> tag)
  (<span class="kw">if</span> (<span class="kw">pair?</span> <span class="kw">exp</span>)
      (<span class="kw">eq?</span> (<span class="kw">car</span> <span class="kw">exp</span>) tag)
      false))</code></pre></div>
<h2 id="定义变量define-和变量赋值set还有-cond">定义变量(define) 和变量赋值(set!)，还有 cond</h2>
<p>这些都不是语言最核心的部分。这里给出完整的代码。</p>
<p>看看效果</p>
<pre><code>&gt; (eval &#39;(begin (define a 10) a) the-global-environment)
10
&gt; (eval &#39;(begin (define a 10) (display a)) the-global-environment)
10
&gt; (eval &#39;(begin (define a 10) (+ a 100)) the-global-environment)
110
&gt; (eval &#39;(begin (define a 10) (set! a 1) (+ a 100)) the-global-environment)
101</code></pre>
<p>最后完整的代码</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span class="co">;; 和宿主语言的交互</span>
(<span class="kw">define</span><span class="fu"> apply-in-underlying-scheme </span>(top-level-value &#39;apply (scheme-environment)))
(<span class="kw">define</span><span class="fu"> true </span><span class="dv">#t</span>)
(<span class="kw">define</span><span class="fu"> false </span><span class="dv">#f</span>)
<span class="co">;; 语言的核心入口</span>
(<span class="kw">define</span><span class="fu"> </span>(<span class="kw">eval</span> <span class="kw">exp</span> env)
  (<span class="kw">cond</span> ((self-evaluating? <span class="kw">exp</span>) <span class="kw">exp</span>)
        ((variable? <span class="kw">exp</span>) (lookup-variable-value <span class="kw">exp</span> env))
        ((quoted? <span class="kw">exp</span>) (text-of-quotation <span class="kw">exp</span>))
        ((assignment? <span class="kw">exp</span>) (eval-assignment <span class="kw">exp</span> env))
        ((definition? <span class="kw">exp</span>) (eval-definition <span class="kw">exp</span> env))
        ((if? <span class="kw">exp</span>) (eval-if <span class="kw">exp</span> env))
        ((lambda? <span class="kw">exp</span>)
         (make-procedure (lambda-parameters <span class="kw">exp</span>)
                         (lambda-body <span class="kw">exp</span>)
                         env))
        ((begin? <span class="kw">exp</span>)
         (eval-sequence (begin-actions <span class="kw">exp</span>) env))
        ((cond? <span class="kw">exp</span>) (<span class="kw">eval</span> (cond-&gt;if <span class="kw">exp</span>) env))
        ((application? <span class="kw">exp</span>)
         (apply (<span class="kw">eval</span> (operator <span class="kw">exp</span>) env)
                (list-of-values (operands <span class="kw">exp</span>) env)))
        (<span class="kw">else</span>
         (error <span class="st">&quot;Unknown expression type -- EVAL&quot;</span> <span class="kw">exp</span>))))

<span class="co">;; 简单的类型</span>
(<span class="kw">define</span><span class="fu"> </span>(self-evaluating? <span class="kw">exp</span>)
  (<span class="kw">cond</span> ((<span class="kw">number?</span> <span class="kw">exp</span>) true)
        ((<span class="kw">string?</span> <span class="kw">exp</span>) true)
        (<span class="kw">else</span> false)))
<span class="co">;; 关于 quote</span>
(<span class="kw">define</span><span class="fu"> </span>(quoted? <span class="kw">exp</span>)
  (tagged-list? <span class="kw">exp</span> &#39;quote))
(<span class="kw">define</span><span class="fu"> </span>(text-of-quotation <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))

<span class="co">;; 关于代码块</span>
(<span class="kw">define</span><span class="fu"> </span>(begin? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;begin))
(<span class="kw">define</span><span class="fu"> </span>(eval-sequence exps env)
  (<span class="kw">cond</span> ((last-exp? exps) (<span class="kw">eval</span> (first-exp exps) env))
        (<span class="kw">else</span> (<span class="kw">eval</span> (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))

(<span class="kw">define</span><span class="fu"> </span>(begin-actions <span class="kw">exp</span>) (<span class="kw">cdr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(last-exp? seq) (<span class="kw">null?</span> (<span class="kw">cdr</span> seq)))
(<span class="kw">define</span><span class="fu"> </span>(first-exp seq) (<span class="kw">car</span> seq))
(<span class="kw">define</span><span class="fu"> </span>(rest-exps seq) (<span class="kw">cdr</span> seq))

<span class="co">;; 支持 if 条件判断</span>
(<span class="kw">define</span><span class="fu"> </span>(if? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;if))
(<span class="kw">define</span><span class="fu"> </span>(eval-if <span class="kw">exp</span> env)
  (<span class="kw">if</span> (true? (<span class="kw">eval</span> (if-predicate <span class="kw">exp</span>) env))
      (<span class="kw">eval</span> (if-consequent <span class="kw">exp</span>) env)
      (<span class="kw">eval</span> (if-alternative <span class="kw">exp</span>) env)))
(<span class="kw">define</span><span class="fu"> </span>(if-predicate <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(if-consequent <span class="kw">exp</span>) (<span class="kw">caddr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(if-alternative <span class="kw">exp</span>)
  (<span class="kw">if</span> (<span class="kw">not</span> (<span class="kw">null?</span> (<span class="kw">cdddr</span> <span class="kw">exp</span>)))
      (<span class="kw">cadddr</span> <span class="kw">exp</span>)
      &#39;false))
(<span class="kw">define</span><span class="fu"> </span>(true? <span class="kw">exp</span>)
  (<span class="kw">eq?</span> <span class="kw">exp</span> &#39;true))
<span class="co">;; 支持 lambda 函数定义</span>
(<span class="kw">define</span><span class="fu"> </span>(lambda? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;lambda))
(<span class="kw">define</span><span class="fu"> </span>(lambda-parameters <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(lambda-body <span class="kw">exp</span>) (<span class="kw">cddr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(make-procedure parameters body env)
  (<span class="kw">list</span> &#39;procedure parameters body env))
(<span class="kw">define</span><span class="fu"> </span>(compound-procedure? p) (tagged-list? p &#39;procedure))
(<span class="kw">define</span><span class="fu"> </span>(procedure-parameters p) (<span class="kw">cadr</span> p))
(<span class="kw">define</span><span class="fu"> </span>(procedure-body p) (<span class="kw">caddr</span> p))
(<span class="kw">define</span><span class="fu"> </span>(procedure-environment p) (<span class="kw">cadddr</span> p))
<span class="co">;; 关于环境的定义</span>
(<span class="kw">define</span><span class="fu"> </span>(extend-environment vars vals base-env)
  (<span class="kw">if</span> (<span class="kw">=</span> (<span class="kw">length</span> vars) (<span class="kw">length</span> vals))
      (<span class="kw">cons</span> (make-frame vars vals) base-env)
      (<span class="kw">if</span> (<span class="kw">&lt;</span> (<span class="kw">length</span> vars) (<span class="kw">length</span> vals))
          (error <span class="st">&quot;Too many arguments supplied&quot;</span> vars vals)
          (error <span class="st">&quot;Too few arguments supplied&quot;</span> vars vals))))
(<span class="kw">define</span><span class="fu"> </span>(make-frame variables <span class="kw">values</span>)
  (<span class="kw">cons</span> variables <span class="kw">values</span>))
(<span class="kw">define</span><span class="fu"> </span>(frame-variables frame) (<span class="kw">car</span> frame))
(<span class="kw">define</span><span class="fu"> </span>(frame-values frame) (<span class="kw">cdr</span> frame))
(<span class="kw">define</span><span class="fu"> </span>(extend-environment vars vals base-env)
  (<span class="kw">if</span> (<span class="kw">=</span> (<span class="kw">length</span> vars) (<span class="kw">length</span> vals))
      (<span class="kw">cons</span> (make-frame vars vals) base-env)
      (<span class="kw">if</span> (<span class="kw">&lt;</span> (<span class="kw">length</span> vars) (<span class="kw">length</span> vals))
          (error <span class="st">&quot;Too many arguments supplied&quot;</span> vars vals)
          (error <span class="st">&quot;Too few arguments supplied&quot;</span> vars vals))))
(<span class="kw">define</span><span class="fu"> </span>(add-binding-to-frame! var val frame)
  (<span class="kw">set-car!</span> frame (<span class="kw">cons</span> var (<span class="kw">car</span> frame)))
  (<span class="kw">set-cdr!</span> frame (<span class="kw">cons</span> val (<span class="kw">cdr</span> frame))))
(<span class="kw">define</span><span class="fu"> </span>(enclosing-environment env) (<span class="kw">cdr</span> env))
(<span class="kw">define</span><span class="fu"> </span>(first-frame env) (<span class="kw">car</span> env))

(<span class="kw">define</span><span class="fu"> primitive-procedures</span>
  (<span class="kw">list</span> (<span class="kw">list</span> &#39;car <span class="kw">car</span>)
        (<span class="kw">list</span> &#39;cdr <span class="kw">cdr</span>)
        (<span class="kw">list</span> &#39;cons <span class="kw">cons</span>)
        (<span class="kw">list</span> &#39;null? <span class="kw">null?</span>)
        (<span class="kw">list</span> &#39;+ <span class="kw">+</span>)
        (<span class="kw">list</span> &#39;- <span class="kw">-</span>)
        (<span class="kw">list</span> &#39;* *)
        (<span class="kw">list</span> &#39;/ <span class="kw">/</span>)
        (<span class="kw">list</span> &#39;display <span class="kw">display</span>)
        ))
(<span class="kw">define</span><span class="fu"> </span>(primitive-procedure-names)
  (map <span class="kw">car</span>
       primitive-procedures))
(<span class="kw">define</span><span class="fu"> </span>(primitive-procedure-objects)
  (map (<span class="kw">lambda</span> (proc) (<span class="kw">list</span> &#39;primitive (<span class="kw">cadr</span> proc)))
       primitive-procedures))
(<span class="kw">define</span><span class="fu"> </span>(setup-environment)
  (<span class="kw">let</span> ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    initial-env))
(<span class="kw">define</span><span class="fu"> the-empty-environment </span>&#39;())
(<span class="kw">define</span><span class="fu"> the-global-environment </span>(setup-environment))

<span class="co">;; 关于变量</span>
(<span class="kw">define</span><span class="fu"> </span>(variable? <span class="kw">exp</span>) (<span class="kw">symbol?</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(lookup-variable-value var env)
  (<span class="kw">define</span><span class="fu"> </span>(env-loop env)
    (<span class="kw">define</span><span class="fu"> </span>(scan vars vals)
      (<span class="kw">cond</span> ((<span class="kw">null?</span> vars)
             (env-loop (enclosing-environment env)))
            ((<span class="kw">eq?</span> var (<span class="kw">car</span> vars))
             (<span class="kw">car</span> vals))
            (<span class="kw">else</span> (scan (<span class="kw">cdr</span> vars) (<span class="kw">cdr</span> vals)))))
    (<span class="kw">if</span> (<span class="kw">eq?</span> env the-empty-environment)
        (error <span class="dv">#f</span> <span class="st">&quot;Unbound variable&quot;</span> var)
        (<span class="kw">let</span> ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
<span class="co">;; 关于 apply 的相关函数</span>
(<span class="kw">define</span><span class="fu"> </span>(application? <span class="kw">exp</span>) (<span class="kw">pair?</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(apply procedure arguments)
  (<span class="kw">cond</span> ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
           (procedure-body procedure)
           (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
        (<span class="kw">else</span>
         (error
          <span class="st">&quot;Unknown procedure type -- APPLY&quot;</span> procedure))))
(<span class="kw">define</span><span class="fu"> </span>(primitive-procedure? proc)
  (tagged-list? proc &#39;primitive))
(<span class="kw">define</span><span class="fu"> </span>(primitive-implementation proc) (<span class="kw">cadr</span> proc))
(<span class="kw">define</span><span class="fu"> </span>(apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))
(<span class="kw">define</span><span class="fu"> </span>(operator <span class="kw">exp</span>) (<span class="kw">car</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(operands <span class="kw">exp</span>) (<span class="kw">cdr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(no-operands? ops) (<span class="kw">null?</span> ops))
(<span class="kw">define</span><span class="fu"> </span>(first-operand ops) (<span class="kw">car</span> ops))
(<span class="kw">define</span><span class="fu"> </span>(rest-operands ops) (<span class="kw">cdr</span> ops))
(<span class="kw">define</span><span class="fu"> </span>(list-of-values exps env)
  (<span class="kw">if</span> (no-operands? exps)
      &#39;()
      (<span class="kw">cons</span> (<span class="kw">eval</span> (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

<span class="co">;; 关于 define</span>
(<span class="kw">define</span><span class="fu"> </span>(definition? <span class="kw">exp</span>)
  (tagged-list? <span class="kw">exp</span> &#39;define))
(<span class="kw">define</span><span class="fu"> </span>(definition-variable <span class="kw">exp</span>)
  (<span class="kw">if</span> (<span class="kw">symbol?</span> (<span class="kw">cadr</span> <span class="kw">exp</span>))
      (<span class="kw">cadr</span> <span class="kw">exp</span>)
      (<span class="kw">caadr</span> <span class="kw">exp</span>)))
(<span class="kw">define</span><span class="fu"> </span>(definition-value <span class="kw">exp</span>)
  (<span class="kw">if</span> (<span class="kw">symbol?</span> (<span class="kw">cadr</span> <span class="kw">exp</span>))
      (<span class="kw">caddr</span> <span class="kw">exp</span>)
      (make-lambda (<span class="kw">cdadr</span> <span class="kw">exp</span>)   <span class="co">; formal parameters</span>
                   (<span class="kw">cddr</span> <span class="kw">exp</span>)))) <span class="co">; body</span>
(<span class="kw">define</span><span class="fu"> </span>(eval-definition <span class="kw">exp</span> env)
  (define-variable! (definition-variable <span class="kw">exp</span>)
                    (<span class="kw">eval</span> (definition-value <span class="kw">exp</span>) env)
                    env)
  &#39;ok)
(<span class="kw">define</span><span class="fu"> </span>(define-variable! var val env)
  (<span class="kw">let</span> ((frame (first-frame env)))
    (<span class="kw">define</span><span class="fu"> </span>(scan vars vals)
      (<span class="kw">cond</span> ((<span class="kw">null?</span> vars)
             (add-binding-to-frame! var val frame))
            ((<span class="kw">eq?</span> var (<span class="kw">car</span> vars))
             (<span class="kw">set-car!</span> vals val))
            (<span class="kw">else</span> (scan (<span class="kw">cdr</span> vars) (<span class="kw">cdr</span> vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
<span class="co">;; 关于 set!</span>
(<span class="kw">define</span><span class="fu"> </span>(assignment? <span class="kw">exp</span>)
  (tagged-list? <span class="kw">exp</span> &#39;set!))
(<span class="kw">define</span><span class="fu"> </span>(assignment-variable <span class="kw">exp</span>) (<span class="kw">cadr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(assignment-value <span class="kw">exp</span>) (<span class="kw">caddr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(eval-assignment <span class="kw">exp</span> env)
  (set-variable-value! (assignment-variable <span class="kw">exp</span>)
                       (<span class="kw">eval</span> (assignment-value <span class="kw">exp</span>) env)
                       env)
  &#39;ok)
(<span class="kw">define</span><span class="fu"> </span>(set-variable-value! var val env)
  (<span class="kw">define</span><span class="fu"> </span>(env-loop env)
    (<span class="kw">define</span><span class="fu"> </span>(scan vars vals)
      (<span class="kw">cond</span> ((<span class="kw">null?</span> vars)
             (env-loop (enclosing-environment env)))
            ((<span class="kw">eq?</span> var (<span class="kw">car</span> vars))
             (<span class="kw">set-car!</span> vals val))
            (<span class="kw">else</span> (scan (<span class="kw">cdr</span> vars) (<span class="kw">cdr</span> vals)))))
    (<span class="kw">if</span> (<span class="kw">eq?</span> env the-empty-environment)
        (error <span class="st">&quot;Unbound variable -- SET!&quot;</span> var)
        (<span class="kw">let</span> ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
<span class="co">;; 关于 cond!</span>
(<span class="kw">define</span><span class="fu"> </span>(cond? <span class="kw">exp</span>) (tagged-list? <span class="kw">exp</span> &#39;cond))
(<span class="kw">define</span><span class="fu"> </span>(cond-clauses <span class="kw">exp</span>) (<span class="kw">cdr</span> <span class="kw">exp</span>))
(<span class="kw">define</span><span class="fu"> </span>(cond-else-clause? clause)
  (<span class="kw">eq?</span> (cond-predicate clause) &#39;else))
(<span class="kw">define</span><span class="fu"> </span>(cond-predicate clause) (<span class="kw">car</span> clause))
(<span class="kw">define</span><span class="fu"> </span>(cond-actions clause) (<span class="kw">cdr</span> clause))
(<span class="kw">define</span><span class="fu"> </span>(cond-&gt;if <span class="kw">exp</span>)
  (expand-clauses (cond-clauses <span class="kw">exp</span>)))

(<span class="kw">define</span><span class="fu"> </span>(expand-clauses clauses)
  (<span class="kw">if</span> (<span class="kw">null?</span> clauses)
      &#39;false                          <span class="co">; no else clause</span>
      (<span class="kw">let</span> ((first (<span class="kw">car</span> clauses))
            (rest (<span class="kw">cdr</span> clauses)))
        (<span class="kw">if</span> (cond-else-clause? first)
            (<span class="kw">if</span> (<span class="kw">null?</span> rest)
                (sequence-&gt;exp (cond-actions first))
                (error <span class="st">&quot;ELSE clause isn&#39;t last -- COND-&gt;IF&quot;</span>
                       clauses))
            (make-if (cond-predicate first)
                     (sequence-&gt;exp (cond-actions first))
                     (expand-clauses rest))))))
<span class="co">;; 底层函数</span>
(<span class="kw">define</span><span class="fu"> </span>(tagged-list? <span class="kw">exp</span> tag)
  (<span class="kw">if</span> (<span class="kw">pair?</span> <span class="kw">exp</span>)
      (<span class="kw">eq?</span> (<span class="kw">car</span> <span class="kw">exp</span>) tag)
      false))</code></pre></div>
<h2 id="其他">其他</h2>
<p>这个解释器，看起来简单，其实已经支持了大多数核心功能了，甚至包括闭包的 实现。一门语言还有其他一些重要的特性需要仔细设计。</p>
<ul>
<li>模块系统</li>
<li>内存管理 gc</li>
<li>代码生成优化</li>
<li>调试器</li>
<li>调优器</li>
<li>特色功能
<ul>
<li>是否支持 continuation</li>
<li>是否支持 coroutine</li>
<li>是否支持 thread</li>
<li>是否支持 macro</li>
<li>是否支持 类型推导</li>
<li>是否支持 OO</li>
<li>是否支持 泛型</li>
<li>是否支持 generator/iterator</li>
</ul></li>
<li>标准库设计
<ul>
<li>Network/File IO</li>
<li>基础数据类型库
<ul>
<li>List</li>
<li>Array</li>
<li>Map</li>
<li>Hash</li>
<li>Set</li>
</ul></li>
</ul></li>
</ul>
</article>
</main>
</body>
</html>
