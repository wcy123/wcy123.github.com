<html>
  <head>
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
</script>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>关于协议设计语言</title>

  <link rel="stylesheet" href="../writ.min.css">
</head>
<body>
<main>
<header>
<h1>关于协议设计语言</h1>
<h3 class="date">2017/01/07 20:19:18</h3>
</header>
<article>
<p>通信系统中存在无数个协议，协议就是把事先规定好的一些规则，发送端按照规则发送，接收端按照规则理解。这个规则，某种程度上来说，就是一门语言。接收端和发送端都符合一个协议，就像他们都是讲同一门语言。很难想象，HTTP 的客户端可以连接 IMAP 服务器。</p>
<p>相比编程语言，协议语言更加简单，注重如何抽象的描述信息，而不在话信息如何在内存中存储和表示。这种描述，通常叫做抽象语法表示(ASN1)。互联网中也出现了一些其他的类似的定义，例如 Protobuf 。</p>
<p>这样的一门语言通常就是数据结构的描述。一般分为简单的数据类型和复杂数据类型。</p>
<h1 id="后向兼容与平滑演进">后向兼容与平滑演进</h1>
<p>无数协议设计证明，我们无法一次就把协议设计好，协议永远会有下一个版本。版本的后向兼容和平滑演进变得十分重要。</p>
<p>兼容需要考虑两个问题。 * 发送者是新版本，接收者是旧版本 * 发送者是旧版本，接收者是旧版本。</p>
<p>后面每种数据类型，都应该考虑这个问题。</p>
<h1 id="简单数据类型">简单数据类型</h1>
<ul>
<li>整数</li>
<li>浮点数</li>
<li>枚举体</li>
</ul>
<p>整数，例如 1，2，3 。</p>
<p>整数一般包含一些属性，描述整数类型本身。例如，范围，即最大值，最小值。理论上这个必须设置，否则理论上，发送者可以发送一个无限大的整数，无论底层如何编码，发送的信息量无穷大，无论带宽多大都传输不过去。</p>
<p>最简单的定义范围的方法就是定义类似 int8, uint8, int16, uint16, int32, uint32, int64, uint64 等等的类型。</p>
<p>对于后向兼容来说，新版本可以让整数的范围变大，但是不能让范围变小。</p>
<ul>
<li>旧版本发送者发送给新版本的接收者，因为范围不会超，所以不会有问题。</li>
<li>新版本发送者发送给旧版本的接收者，如果超过范围，接收者则无法接收。导致不兼容。</li>
</ul>
<p>浮点数，一般很少用到。通信中，也常常用定点数代替浮点数。小数也就是一种特殊的整数。</p>
<p>枚举体，例如 &quot;红“， ”黑“， ”白“。这个应用最广。其实和整数类似。但是比整数更加准确的描述语义。</p>
</article>
</main>
</body>
</html>
