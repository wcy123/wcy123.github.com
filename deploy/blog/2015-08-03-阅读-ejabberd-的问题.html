<html>
  <head>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
       (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
         m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
           })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-98267158-1', 'auto');
    ga('send', 'pageview');

    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
      "HTML-CSS": {
      preferredFont: "STIX"
      },
      CommonHTML: {
      scale: 100
      },
      tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']]
      }});
</script>
<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
</script>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>阅读 ejabberd 的问题</title>

  <link rel="stylesheet" href="../writ.min.css">
</head>
<body>
<main>
<header>
<h1>阅读 ejabberd 的问题</h1>
<h3 class="date">2015/08/03 10:44:29</h3>
</header>
<article>
<h1 id="设计问题">设计问题</h1>
<h2 id="event_handler-vs-hooks"><code>event_handler</code> vs <code>hooks</code></h2>
<p>用 event handler 是标准的 OTP 的行为，可以提高可读性。</p>
<h2 id="ejabberd_app-的启动过程"><code>ejabberd_app</code> 的启动过程</h2>
<p>没有完全使用 supervisor 的技术。</p>
<p><a href="../../../07/30/ejabberd-%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/index.html#app_deps">没有利用 application 的依赖关系</a> <a href="../../../07/30/ejabberd-%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/index.html#app_deps2">执行顺序的依赖关系</a> ## 直接使用 lager</p>
<p><a href="../../../07/30/ejabberd-%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/index.html#lager">这里</a></p>
<p>lager 可以注册为 error log event manger 中的一个 event handler ，为啥还要直接使用 lager ?</p>
<p>可以继续调用 <code>error_log:error_report</code> ，而不是 <code>lager:error</code>。</p>
<h2 id="用-mnesia-表格还是-ets-表格">用 mnesia 表格还是 ets 表格。</h2>
<p>还有的地方直接用 ets api 访问 mnesia 表格。</p>
<h2 id="动态-cluster-的问题">动态 cluster 的问题。</h2>
<p><a href="../../../07/30/ejabberd-%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/index.html#dynamic_cluster">持动态进入</a>。 <a href="../../../07/30/ejabberd-%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/index.html#dynamic_cluster2">这里</a>。</p>
<h2 id="如何构架集群">如何构架集群</h2>
<p>TODO</p>
<h2 id="hooks">hooks</h2>
<p>这里违反的原则是, “一个模块只在一个进程中运行”</p>
<p>P426 &quot;erlang programming&quot;</p>
<blockquote>
<p>So where possible, avoid unnecessary process interaction and unnecessary concurrency.</p>
</blockquote>
<blockquote>
<p>You should always implement a process loop and its peripheral functions in one module.</p>
</blockquote>
<blockquote>
<p>Hide all message passing in a functional interface</p>
</blockquote>
<blockquote>
<p>Processes should have well-defined behaviors and rols in the system.</p>
</blockquote>
<p>2</p>
<h1 id="代码风格问题">代码风格问题</h1>
<p>这个问题比较普遍。</p>
<ol style="list-style-type: decimal">
<li><a href="../../../07/30/ejabberd-%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/index.html#style1">多个 ejabberd_config:start</a>。</li>
<li><a href="../../../07/30/ejabberd-%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/index.html#let_it_crash1">let it crash1</a>。</li>
</ol>
<h2 id="defensive-programming-vs-let-it-crash">defensive programming vs let it crash</h2>
<p>例如:</p>
<pre><code>start(_StartType, _StartArgs) -&gt;
    Res = case application:start(crypto) of
              ok -&gt; ok;
              {error, {already_started, _}} -&gt; ok;
              Err -&gt; Err
          end,
    case Res of
        ok -&gt;
            case p1_sha:load_nif() of
                ok -&gt;
                    case p1_tls_sup:start_link() of
                        {ok, Pid} -&gt;
                            {ok, Pid};
                        Error -&gt;
                            Error
                    end;
                Error -&gt;
                    Error
            end;
        Error -&gt;
            Error
    end.</code></pre>
<pre><code>start(_StartType, _StartArgs) -&gt;
    ok = application:ensure_start(crypto),  %% return ok if already_started
    ok =  p1_sha:load_nif(), %% raise error if so
    {ok, Pid} = p1_tls_sup:start_link().</code></pre>
<p><code>application:start()</code> 期待 <code>start</code> 函数返回一个 <code>{ok,Pid}</code> ，所以中间 返回任何 <code>Error</code> 都会导致 <code>application:start</code> 抛出异常。 那么，应该在 及早的抛出异常。这样从 log 中就可以清晰的看到是那一步骤出错。</p>
<p>一个极端例子，假设 <code>p1_sha:load_nif()</code> 有可能返回错误 <code>{error, foo}</code> <code>p1_tl_sup:start</code> 也有可能返回同样的错误，那么 <code>application:start</code> 是 说 bad return value, <code>{error,foo}</code> ，我们就无法定位是那一个模块抛出异 常。 这个例子比较简单，这个问题还不是很明显，如果程序比较大的时候，这 种风格的代码就会让调试十分困难。</p>
</article>
</main>
</body>
</html>
