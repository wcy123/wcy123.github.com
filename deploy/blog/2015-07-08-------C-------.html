<html>
  <head>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
       (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
         m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
           })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-98267158-1', 'auto');
    ga('send', 'pageview');

    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
      "HTML-CSS": {
      preferredFont: "STIX"
      },
      CommonHTML: {
      scale: 100
      },
      tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']]
      }});
</script>
<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
</script>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>编程风格： C++ 类的结构</title>

  <link rel="stylesheet" href="../writ.min.css">
</head>
<body>
<main>
<header>
<h1>编程风格： C++ 类的结构</h1>
<h3 class="date">2015/07/08 09:05:31</h3>
</header>
<article>
<p>如果一个类比较复杂，我会按照下面的顺序写一个类。</p>
<p>{% highlight c++ %} class A : public interface{ public: // 类静态函数 static class_method1() ; // private: static class_priate_method1() ; // 尽量不要有 public: explicit A(); // 尽量使用 explicit private: // 没有拷贝构造函数，就显式禁止拷贝构造函数，如果有，则显示定义 A( const A&amp; x); // 禁止 = 操作符重载。如果有，则显示定义。 A&amp; operator=(const A&amp; other); public: virtual // 这里一定想好，是不是应该有一个 virtual ~A(); private: // 实现父类的公有接口。 virtual void foo(); private: // 类私有函数 private: // 真正的类私有变量 };</p>
<p>// 尽量不要使用，protected // 尽量不要使用超过三层以上的继承关系。 {% endhighlight %}</p>
<h2 id="详细展开讨论">详细展开讨论</h2>
<h3 id="类方法-class-method-static-member-function">类方法 (class method, static member function)</h3>
<p>这个不属于类对象，通常是一些构造对象用的函数。</p>
<p>{% highlight c++ %} class A_interface { public: static A * create(); public: virtual void interface1() = 0; virtual void interface2() = 0; }; {% endhighlight %}</p>
<p>这是一个比较好的父类结构</p>
<ul>
<li>类没有成员变量。</li>
<li>类没有构造函数，因为没有成员变量。</li>
<li>类没有私有函数，没有非虚函数。</li>
<li>只有一个 类方法 <code>Create()</code></li>
<li>从用户的角度上看，这个结构一目了然，调用</li>
</ul>
<p>{% highlight c++ %} A_interface * obj= A_interface::Create(); obj-&gt;interface1(); obj-&gt;interface2(); {% endhighlight %}</p>
<h3 id="构造函数">构造函数</h3>
<p>构造函数尽量使用 explicit 的关键字。这个关键字可以阻止意想不到的构造函 数调用。</p>
<h3 id="拷贝构造函数">拷贝构造函数</h3>
<p>如果不想使用拷贝构造函数，给他弄成 private ，这样的好处是，无论是谁， 包括父类，子类，还是用户，都不能访问。拷贝构造函数在很多时候，隐含调用， 增加了调试难度，同时也是 bug 产生的发源地。这样做的之后，又如下限制，</p>
<p>不能声明这样的函数 <code>Foo(A x)</code> ，因为这个需要拷贝构造函数调用。同样原理， 不能使用 <code>vector&lt;A&gt;</code>等容器。我体会实际使用中，这样类型的类还占大多数。 很多情况下，都是指针或者应用传递才有意义。赋值操作符重载</p>
<p>这个也是 bug 的发源地。原理同拷贝构造函数类似。</p>
<h3 id="析构函数">析构函数</h3>
<p>如果类里面有虚函数，析构函数一定要是虚函数。</p>
<h3 id="虚函数的实现">虚函数的实现</h3>
<p>尽管父类的虚函数是 public ，但是在子类实现的时候，最好是 private</p>
<h2 id="一个例子">一个例子</h2>
<p>我写一个例子程序说明我的想法。这个程序是 <code>busybox</code> ，就是用一个程序实 现很多 <code>unix</code> 下常用的命令。</p>
<h3 id="首先创建一个-cmd.h">首先创建一个 cmd.h</h3>
<p>{% highlight c++ %} #pragma once #include <string> // using namespace std class cmd_c { public: static cmd_c * create(std::string cmd); public: virtual ~cmd_c(); public: virtual int execute(int argc, char * argv[]) = 0; }; {% endhighlight %}</p>
<ul>
<li>用 <code>#progam once</code> 代替</li>
</ul>
<p>{% highlight c++ %} #ifndef CMD_H #define CMD_H .... #endif {% endhighlight %}</p>
<p><code>#program once</code> 的好处是，短小。不用三行</p>
<p>也不用担心 <code>CMD_H</code> 宏重命名的问题。如果你有连个头文件，一不小心（概率 很小），两个头文件用同样的宏保护，而且两个头文件同时被引用，就会出问题。</p>
<p>坏处就是，这个不是所有的编译器都支持，但是幸运的是，几乎所有的编译器都 支持，包括 vs, gcc, clang 等等。</p>
<ul>
<li>不要使用 using namespace std</li>
</ul>
<p>在头文件的定义中，尽量不要 using namespace std 这样会引起命名空间污 染。如果你觉得 <code>std::string</code> 比 <code>string</code> 长，每次输入 <code>std::</code> 很麻 烦，可以在 cpp文件中，<code>using namespace std</code> 。头文件可能被其他用户 引用，其他用户也许不想使用 namespace <code>std</code>。</p>
<ul>
<li><p><code>virtual ~cmd_c</code> 很重要，保证析构函数是虚函数，否则不能调用子类的析 构函数。</p></li>
<li><p>不用禁止构造函数。</p></li>
</ul>
<p>因为 <code>execute</code> 都是纯虚函数，就不要声明私有的构造函数了。因为如果一 个类有纯虚函数，则不能构造对象。因为只能通过 <code>create</code> 函数创建 <code>cmd_c</code> 的子类对象，否则无法创建一个 <code>cmd_c</code> 的对象。这就是纯虚函数 的好处。</p>
<ul>
<li>初学 <code>C++</code> 的，很容易忽略纯虚函数的作用。</li>
</ul>
<h2 id="创建-main.cpp">创建 main.cpp</h2>
<p>{% highlight c++ %} #include &quot;cmd.h&quot; using namespace std; int main(int argc, char <em>argv[]) { cmd_c </em> cmd = cmd_c::create(string(argv[0])); int ret = cmd-&gt;execute(argc,argv); delete cmd; return ret; } {% endhighlight %}</p>
<p>从用户的角度上看 <code>cmd_c</code> 这个类，十分清爽。</p>
<h2 id="创建-cmd_args.h-第一个-cmd_c-的实现">创建 <code>cmd_args.h</code> ，第一个 <code>cmd_c</code> 的实现</h2>
<p>{% highlight c++ %} #pragma once #include &quot;cmd.h&quot; class cmd_args_c: public cmd_c { public: static cmd_c * create(); private: explicit cmd_args_c(); explicit cmd_args_c(const cmd_args_c&amp;); cmd_args_c&amp; operator= (const cmd_args_c&amp;); virtual ~cmd_args_c(); private: virtual int execute(int argc, char * argv[]); }; {% endhighlight %}</p>
<ul>
<li>禁止了构造函数，拷贝构造函数，赋值操作符重载。</li>
<li>也禁止了析构函数。因为父类的析构函数是虚函数，所以子类可以重载虚函数。</li>
</ul>
<h3 id="创建-cmd_args.cpp">创建 <code>cmd_args.cpp</code></h3>
<p>{% highlight c++ %} #include <iostream> using namespace std; #include &quot;cmd.h&quot; #include &quot;cmd_args.h&quot; cmd_args_c::cmd_args_c() { } cmd_args_c::cmd_args_c(const cmd_args_c&amp;) { } cmd_args_c&amp; cmd_args_c::operator= (const cmd_args_c&amp;) { return <em>this; } cmd_args_c::~cmd_args_c() { } cmd_c </em> cmd_args_c::create() { return new cmd_args_c(); } int cmd_args_c::execute(int argc, char* argv[]) { for(int i = 0; i &lt; argc; ++i){ cout &lt;&lt; &quot;argv[&quot; &lt;&lt; i &lt;&lt; &quot;]:&quot; &lt;&lt; argv[i] &lt;&lt; endl; } return 0;</p>
<p>} {% endhighlight %}</p>
<h3 id="创建-cmd.cpp定义如何创建具体对象">创建 cmd.cpp，定义如何创建具体对象</h3>
<p>{% highlight c++ %} #include <cassert> #include &quot;cmd.h&quot; #include &quot;cmd_args.h&quot; using namespace std;</p>
<p>cmd_c::~cmd_c() { } static struct { const char * name; cmd_c* (<em>func)(); } command_table [] = { {&quot;./args&quot;, cmd_args_c::create }, {NULL,NULL} }; cmd_c </em> cmd_c::create(string cmd) { cmd_c * ret = NULL; for(int i = 0; command_table[i].name !=NULL; ++i){ if(cmd == command_table[i].name){ ret = command_table[i].func(); break; } } assert(ret); return ret;</p>
<p>} {% endhighlight %}</p>
<p>在 cmd.cpp 里面可以放心大胆的使用 using namespace std ，爱怎么弄怎么弄。 没有名字污染的问题。</p>
<p>在 <code>cmd.cpp</code> 里面要定义 <code>~cmd()</code> 否则链接的时候会报错</p>
<p>{% highlight bash%} cmd_args.cpp:(.text+0xb1): undefined reference to `cmd_c::~cmd_c()' {% endhighlight %}</p>
<p>定义 <code>command_table</code> ，这里使用了匿名结构体。因为只有这一个全局变量， 可以避免名字空间污染，也可以避免为了起名浪费脑细胞。</p>
<p><code>command_table</code> 是 static 变量，遵循原则，“尽量减少变量的作用域”，</p>
<p>为了遵循这个原则，是不是可以把 <code>command_table</code> 放在 <code>cmd_c::create</code> 的 内部。</p>
<p>{% highlight c++ %} cmd_c * cmd_c::create(string cmd) { static .... command_table ...; } {% endhighlight %}</p>
<p>这样违反了另一个原则，“分离数据和实现” 。这里是用来注册子类的构造方法 的地方， <code>cmd_c</code> 的子类实现者要很容易找到在哪里注册一个新的子类实现， 而不用关心 <code>cmd_c::create</code> 的具体实现了。</p>
<p><code>cmd_c::create</code> 的结尾用 <code>assert(0)</code> 表示没有实现的功能 ，如果以后写得 复杂了，需要处理如果命令找不到怎么办。这里为了简单，就不处理了。</p>
<p>编译之，哈哈</p>
<p>因为有多个 cpp 的文件，写一个简单的 Makefile</p>
<p>{% highlight makefile %} CXXFLAGS += -Wall -Werror -Wextra all: busybox</p>
<p>busybox: main.o cmd.o cmd_args.o $(CXX) -o $@ $+ {% endhighlight %}</p>
<p>注意： <code>-Wall -Werror -Wextra</code> 是一个很好的习惯，尽量尽量好准守。我用 了两个“尽量”。项目初期就加上这个，其实影响很小，到了项目后期，如果除掉 所有的 warning 还是很麻烦的事。一个好的程序员，对于 warning 应该产生罪 恶感。</p>
<h3 id="使用-make">使用 make</h3>
<p>{% highlight bash %} make clang++ -Wall -Werror -Wextra -c -o main.o main.cpp clang++ -Wall -Werror -Wextra -c -o cmd.o cmd.cpp clang++ -Wall -Werror -Wextra -c -o cmd_args.o cmd_args.cpp clang++ -o busybox main.o cmd.o cmd_args.o {% endhighlight %}</p>
<p>运行</p>
<p>{% highlight bash %} bash$ ln -s ./busybox args bash$ ./args argv[0]:./args bash$ ./args show me argv[0]:./args argv[1]:show argv[2]:me {% endhighlight %}</p>
<p>创建一个符号连接到 busybox 上，这个是 Linux 下的通用做法。保证 &quot;./args&quot; 是第一个参数 <code>argv[0]</code>。</p>
<p>运行结果就自说明了。</p>
<p>这只是一个例子，很容易处理其他情况，例如，</p>
<ul>
<li>不在当前目录运行的时候，<code>argv[0]</code> 不是 &quot;./args‘怎么处理，</li>
<li>命令找不到怎么处理。</li>
<li>怎么添加一个新的命令。例如 <code>cmd_ls_c</code>, <code>cmd_cp_c</code></li>
</ul>
<p>其他问题：</p>
<ul>
<li><code>cmd.cpp</code> 依赖于所有子类的实现，怎么破？</li>
<li><code>cmd_args_c::create</code> 没有参数，如果要传递参数怎么破？</li>
</ul>
</article>
</main>
</body>
</html>
